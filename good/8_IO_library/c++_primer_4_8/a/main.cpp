#include <iostream>
#include <string>
using namespace std;
//此程序有个问题，在windows操作系统下用ctrl＋z结束输入后程序处于等待状态，
//需要再次按下回车才可以正常结束。
//如：输入abcd^Z
//不结束，要再次输入^Z，回车，回车才结束。
//原因分析如下：
//输入缓冲是行缓冲。当从键盘上输入一串字符并按回车后，这些字符会首先被送到输入缓冲区中存储。
//每当按下回车键后，cin.get() 就会检测输入缓冲区中是否有了可读的数据。cin.get() 还会对键盘上是否有作为流结束标志的 Ctrl+Z 
// 或者 Ctrl+D 键按下作出检查，其检查的方式有两种：阻塞式以及非阻塞式。
// 
// 阻塞式检查方式指的是只有在回车键按下之后才对此前是否有 Ctrl+Z 组合键按下进行检查，
// 非阻塞式样指的是按下 Ctrl+D 之后立即响应的方式。如果在按 Ctrl+D 之前已经从键盘输入了字符，
// 则 Ctrl+D的作用就相当于回车，即把这些字符送到输入缓冲区供读取使用，此时Ctrl+D不再起流结束符的作用。
// 如果按 Ctrl+D 之前没有任何键盘输入，则 Ctrl+D 就是流结束的信号。
//
// Windows系统中一般采用阻塞式检查 Ctrl+Z、Unix/Linux系统下一般采用非阻塞式的检查 Ctrl+D。
// 楼主是在Windows系统下，因此使用阻塞式的 Ctrl+Z 来标识流的结束。
//
// 这种阻塞式的方式有一个特点：只有按下回车之后才有可能检测在此之前是否有Ctrl+Z按下。还有一个特点就是：
// 如果输入缓冲区中有可读的数据则不会检测Ctrl+Z（因为有要读的数据，还不能认为到了流的末尾）。还有一点需要知道：Ctrl+Z产生的不是一个普通的ASCII码值，也就是说它产生的不是一个字符，所以不会跟其它从键盘上输入的字符一样能够存放在输入缓冲区。明白了这几点之后就可以来解释这个问题了。
//
// 从键盘上输入abcd^z 加回车之后在Windows系统上是这样处理的：由于回车的作用，
// 前面的 abcd 等字符被送到输入缓冲区（注意：上面说过了，^z不会产生字符，所以更不会存储到输入缓冲区，缓冲区中没有 ^z 的存在）。
// 这时，cin.get() 检测到输入缓冲区中已经有数据存在（因此不再检查是否有 ^z 的输入），于是从缓冲中读取相应的数据。如果都读取完了，
// 则输入缓冲区重新变为空，cin.get() 等待新的输入。可见，尽管有 ^z 按下，但是由于在此之前还有其它输入字符（abcd），所以流也不会结束。
//
// 因此，输入流结束的条件就是：^z 之前不能有任何字符输入（回车除外），否则 ^z 起不到流结束的作用。
// 故输入：abcd^Z
// 后只是把abcd读入缓冲，这里的^Z的作用就是让abcd读入缓冲，并没有起到结束文件的作用。再次输入^Z，回车把^Z读入缓冲。
// 然后下一个回车系统才判断上次输入的^Z。故结束循环。
int main()
{
	string world;
	while (cin >> world)
		cout << world << endl;
	return 0;
}
// 可是在我自己试的时候输入，第四行是程序输出了一个小箭头，而不是像上面网上说的，~z不是字符，没有放入缓冲区，到底怎么一回事啊
// abcd^Z
// ^Z

// abcd
// Press any key to continue . . .

//