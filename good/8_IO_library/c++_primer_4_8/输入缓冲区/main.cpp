#include "stdio.h"
/*
我想以一个例子说明，比如我想把一篇文章以字符序列的方式输出到计算机显示器屏幕上，
那么我的程序内存作为数据源而显示器驱动程序作为数据目标，如果数据源直接对数据目标发送数据的话。
数据目标获得第一个字符，便将它显示。然后从端口读取下一个字符，
可是这时就不能保证数据源向端口发送的恰好是第二个字符（也许是第三个，而第二个已经在数据目标显示时发送过了）。
这样的话就不能保证输出的数据能完整的被数据目标所接受并处理。
为了解决这个问题，我们需要在数据源与数据目标中间放置一个保存完整数据内容的区域，那就是 “缓冲区”。这样的话，
数据源可以不考虑数据目标正在处理哪部分数据，只要把数据输出到缓冲区就可以了，数据目标也可以不考虑数据源的发送频率，
只是从缓冲区中依次取出下一个数据。从而保证了数据发送的完整性，同时也提高了程序的效率。
*/
void test1()
{
	char c;
	c=getchar(); /*从键盘读入字符直到回车结束*/
	//getchar()在这里它只返回你输入字符串的第一个字符，并把返回值赋值给c

	putchar(c); /*显示输入的第一个字符*/
}

void test2()
{
	char c; // getchar()函数运行时，标准输入等待(键盘)输入，我敲一行字符后，按下回车键的时候，向输入缓冲区中放入一了串字符，程序开始继续执行
			// getchar()函数的下一个语句，应该就是从缓冲区中读一个字符，本函数读入一个字符后，将字符赋值给c，然后判断c是不是字符
			// '\n'如果不是，则继续从缓冲区中读入字符，重复动作。
	while ((c=getchar()) != '\n') /*每个getchar()依次读入一个字符*/
		printf("%c", c); /*按照原样输出*/
	// 1，读入一个字符。2，赋值运算。3，比较运算
}
/*
程序运行时，首先停下来，等你输入一串字符串，输入完毕后，它把你输入的整个字符串都输出来了，咦，
你不是说getchar()只返回第一个字符么，这里怎么？
因为我们输入的字符串并不是取了第一个字符就把剩下的字符串丢掉了，它还在我们的内存中，就好比，
开闸放水，我们把水放到闸里去以后，开一次闸就放掉一点，开一次就放掉一点，直到放光了为止，
这里开闸动作就相当于调用一次getchar()。我们输入的字符串也是这么一回事，首先我们输入的字符串是放在内存的缓冲区中的，
我们调用一次getchar()就把缓冲区中里出口最近的一个字符输出，也就是最前面的一个字符输出，
输出后，就把它释放掉了，但后面还有字符串，所以我们就用循环把最前面的一个字符一个个的在内存中释放掉，
直到不满足循环条件退出为止。
例子中循环条件里的'\n'实际上就是你输入字符串后的回车符，所以意思就是说，直到遇到回车符才结束循环，
而getchar()函数就是等待输入（或缓冲区中的数据）直到按回车才结束，所以实现了整个字符串的输出。
当然，我们也可以把循环条件改一下，比如while ((c=getchar())!='a')，什么意思呢，意思就是遇到字符'a'就停止循环，
当然意思是如果你输入“12345a213123\n”那么只会输出到a，结果是12345a。
再次注意：用getchar()它是从“流”中间去读取，所以第一个getchar()接受的是刚刚中断的流队列中即将出列的第一个字符
（不限于回车符，上面举过例子了），如果流队列不为空，执行getchar()就继续放水，直到把回车符也放空为止，
空了之后再在执行getchar()就停下等待你的输入了；我们用getch()为什么每次都是等待用户的输入呢？因为getch()是从键盘接收，
即时的接收，并不是从stdin流中去读取数据。
补充：按键盘上的回车产生了2个字符:回车符('\r')和换行符('\n')。回车符'\r'(CR:carriage return:倒车）使光标回到这行的首部，
换行符('\n')(new line)然后再换行。
				  所以当输入字符'w',并按下回车键以后。首先得到回车符。那个getchar函数结束了。但是还存在一个换行符。
				  所以如果用getchar()来做判断的时候。最好再写一次getchar()清除缓冲区的'\n'.
*/

// 疑问：""""按键盘上的回车产生了2个字符"""""""好像只产生了'\n'这个字符，不然下边的循环怎么回事，我也调试的看了，没有'\r'
// 这个字符。
void test3()
{
	char c; // 这个比较有意思，
	/*1，getchar函数执行。
	  2, 我向缓冲区中输入了一个字符串之后，按下回车键。
	  3，getchar继续执行，读取缓冲区中第一个字符，将它赋值给c，判断是否为'\r'，不是就输出这个字符，读下一个缓冲区中数据
	  4，当下一个缓冲区中的数据为'\r'时，循环就应该结束了，不知道为什么不结束呢，调试中发现没有收到字符'\r'只有字符'\n'
	*/
	// 0x0a 10 对应字符 '\n' // 换行键
	// 0x0d 13 对应字符 '\r' // 这个是回车键。我可能明白了一个问题，回车键是给操作系统的，告诉操作系统，我输入结束了，而且
							 // 回车之后，我再输入一个换行，这个是一个字符，getchar函数可以得到的。这个字符会进入输入流中
							 // 回车只是一个给操作系统的信号，不知道我这样理解对不对。
	// printf("%c", 0x0a);
	// printf("%c", 0x0d);
	while ((c = getchar()) != '\r')
		printf("%c", c); 
}

void test4()
{
	for(int i = 0; i < 10; ++i)
	{
		char ch = getchar();
		printf("%c", ch);
		fflush(stdin);
	} 
	/*
	C 标准规定 fflush()函数是用来刷新输出（stdout）缓存的。对于输入（stdin），它是没有定义的。
	但是有些编译器也定义了 fflush( stdin )的实现，比如微软的VC。其它编译器是否也定义了 fflush( stdin )的实现应当查找它的手册。
	GCC编译器没有定义它的实现，所以不能使用 fflush( stdin )来刷新输入缓存。
	对于没有定义 fflush( stdin )的编译器，可以使用 fgets()函数来代替它（比用 getchar()、scanf()等函数通用性好）。
	可以这样忽略输入流中留下的回车等其它输入，从而使下一次的输入总保持一个“干净”的状态。（这个是任何平台下都可以的）
	// ...
	char sbuf[1024];
	// ...
	fgets( sbuf, 1024, stdin );
	// ...
	在windows 的vc下面就可以这样了：
	for(int i=0;i<10;++i)
	{
	char ch=getchar();
	fflush(stdin); //每次都会有等待状态了
	}
	4．总结主要看getch(),getche()的是否显示，getchar()是读取流，而且和前面两个函数不是一个库。掌握清空缓冲区的方法。
	二。fflush(   FILE   *   pStream   )     清空一个流  
	pStream可以是stdin, stdout, stderr, stdprn, stdaux
	flushall()     清空所有流   
	需要包含   stdio.h
	*/
}



int main()
{
	// getchar(); // 这个是从标准输入输出设备读取一个字符的标准库函数。其它的就先不要理了。
	// test1();
	// test2();
	// test3();
	test4();
	return 0;
}