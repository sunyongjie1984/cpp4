 /**
 * Copyright(c) 2006-2010 TOSHIBA Medical Systems Corporation,
 * All Rights Reserved.
 *
 * Internal implementation of MQ communication. wrapper by MQ API
 * Filename: InnerConnector.cpp
 *
 * Spec: TCOM_MP_FW_CFW_RECEIVEMESSAGE
 * Spec: TCOM_MP_FW_CFW_CONNECT
 * Spec: TCOM_MP_FW_CFW_DISCONNECT
 * Spec: TCOM_MP_FW_CFW_SEND_SYNCHRONIZED
 * Spec: TCOM_MP_FW_CFW_SEND_ASYNCHRONIZED
 * Spec: TCOM_MP_FW_CFW_CREATE_BROADCAST_CHANNEL
 * Spec: TCOM_MP_FW_CFW_SEND_BROADCAST
 * Spec: TCOM_MP_FW_CFW_CONNECT_BROADCAST
 * Spec: TCOM_MP_FW_CFW_RECEIVE_BROADCAST
 *
 * @author       Zhang Yunfeng  Xue Kang
 * @version      1.01         Date: 2008-08-21
 * @author      Xue Kang Wei Xueyuan
 * @version      2.00         Date: 2009-02-03
 * @author      Yang Ke, Yu Tianyi(Modified for MPlusV5)
 * @version      3.00         Date: 2010-07-05
 */

#include "stdafx.h"
#include <afxtempl.h>
#include "mpluscomm.h"
#include "..\Common\MPlusMessage.h"
#include "MPlusCFWInnerGlobal.h"
#include "MPlusCFWErrorsDef.h"
#include "InnerConnector.h"
#include "..\Common\MsgSerializer.h"
#include "MPlusCFWUtility.h"
#include "MPlusCFW_TraceLogHelper.h"
// yutianyi add start on 2010-06-09 for Change Record CFW003&004&005&006
// yangke modified start on 2010-9-28 for code review log
#include <Ntsecapi.h>
// yangke  modified end on 2010-9-28 for code review log
// yutianyi add end on 2010-06-09 for Change Record CFW003&004&005&006
// yutianyi add start on 2010-06-22 for Change Record CFW005
#include "cfw\MplusMessageFactory.h"
// yutianyi add end on 2010-06-22 for Change Record CFW005
// yutianyi add start on 2010-07-05 for Change Record CFW003&004&005&006
#include <WtsApi32.h>
// yutianyi add end on 2010-07-05 for Change Record CFW003&004&005&006
// yutianyi add start on 2010-06-30 for Change Record CFW005&006
#include "sddl.h"
#include <lm.h>
// yutianyi add end on 2010-06-30 for Change Record CFW005&006

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

namespace MPLUS
{
    namespace FW
    {
        namespace COMM
        {

// String for format ms queue name
#define MPLUSCFW_STRING_FORMATNAME_PREFIX _T( "DIRECT=OS:%s\\private$\\%s" )
// yutianyi add start on 2010-06-09 for Change Record CFW003&004&005&006
#define MPLUSCFW_CONNCT_CHARACTER   _T("_")
#define MPLUSCFW_QUEUE_FORMAT       _T("%s_%d")
// yutianyi add end on 2010-06-09 for Change Record CFW003&004&005&006
// yutianyi add start on 2010-06-22 for Change Record CFW005
#define MPLUSCFW_CHECK_QUEUE_MESSAGE    _T("ChechQueueAcrossHost")
// yutianyi add end on 2010-06-22 for Change Record CFW005
// String for version
#define MPLUSCFW_STRING_VERSION_PREFIX _T( "MPLUS_CFW_V_%u" )
// yutianyi add start on 2010-09-15 for Change Record CFW005
#define MPLUSCFW_BCMSGTYPE_QUERYHOSTINFO    _T("QuerySessionList")
#define MPLUSCFW_BCMSG_SPLIT_CHARACTOR _T("!@#")
#define MPLUSCFW_QUERYHOSTINFO      _T("QueryHostInfo")
#define BCMANAGER_QMLACCESS _T( "BCManager.QMLAccess" )
#define PERCENT_D _T( "%d" )
#define PRIVATE$ _T( "\\private$\\" )
#define TIMEOUT_GETALLSESSIONLIST 5000
// yutianyi add end on 2010-09-15 for Change Record CFW005
// Queue guid
#define MPLUSCFW_QUEUE_GUID    \
    { \
        0x5210139d, 0xe213, 0x4102, \
        { \
            0xba, 0xc5, 0x18, 0x11, 0xde, 0x30, 0xfc, 0x39 \
        } \
    }
// yangke modified start on 2010-9-28 for code review log
#define MPLUSCFW_MAX_USERNAME_LEN 256
// yangke  modified end on 2010-9-28 for code review log
// Private queue name
const LPCTSTR MPLUSCFW_C_STRING_PRIVATE = _T( "\\private$\\" );
// Wait timeout for receive message
const DWORD MPLUSCFW_TEMPARARY_WAIT_TIME = 50ul;
// Wait timeout for unlisten operation
const DWORD MPLUSCFW_UNLISTEN_WAIT_TIME = 100ul;
// Version of the dll
const DWORD MPLUSCFW_VERSION_NUMBER = 0ul;
// Sleep time for given up execute chance
const DWORD MPLUSCFW_SLEEPTIME_ZERO = 0ul;
// Read timeout for SendSync operation
const DWORD MPLUSCFW_SENDSYNC_READRET_TIME = 50ul;
// Message priority high
const int MPLUSCFW_HIGHEST_PRIORITY = 7;
// Message priority low
const int MPLUSCFW_LOWEST_PRIORITY = 0;
// Empty string length
const unsigned int MPLUSCFW_EMPTYSTRING_LEN = 0u;
// Const zero
const DWORD MPLUSCFW_CONST_ZERO = 0ul;
// Timeout no wait
const DWORD MPLUSCFW_TIMEOUT_NOWAIT = 0ul;
// Error occurred in watch thread 
const UINT MPLUSCFW_ERROR_WATCHTHREAD_RETURN = 1u;

// MQ properties initialize const
// yutianyi modify start on 2010-07-14 for Change Record CFW005
/*const DWORD MPLUSCFW_MQPROPVARIANT_SIZE_SIX = 6ul;
const DWORD MPLUSCFW_MSGPROPID_SIZE_SIX = 6ul;
const DWORD MPLUSCFW_HRESULT_SIZE_SIX = 6ul;*/
const DWORD MPLUSCFW_MQPROPVARIANT_SIZE_EIGHT = 8ul;
const DWORD MPLUSCFW_MSGPROPID_SIZE_EIGHT = 8ul;
const DWORD MPLUSCFW_HRESULT_SIZE_EIGHT = 8ul;
const DWORD MPLUSCFW_MQPROPVARIANT_SIZE_SEVEN = 7ul;
const DWORD MPLUSCFW_MSGPROPID_SIZE_SEVEN = 7ul;
const DWORD MPLUSCFW_HRESULT_SIZE_SEVEN = 7ul;
// yutianyi modify end on 2010-07-14 for Change Record CFW005
const DWORD MPLUSCFW_MQPROPVARIANT_SIZE_THREE = 3ul;
const DWORD MPLUSCFW_MSGPROPID_SIZE_THREE = 3ul;
const DWORD MPLUSCFW_MQPROPVARIANT_SIZE_ONE = 1ul;
const DWORD MPLUSCFW_MSGPROPID_SIZE_ONE = 1ul;
const DWORD MPLUSCFW_HRESULT_SIZE_ONE = 1ul;
const DWORD MPLUSCFW_ARRAY_CONUT_ZERO = 0ul;
const DWORD MPLUSCFW_ARRAY_CONUT_TWO = 2ul;
const DWORD MPLUSCFW_ARRAY_CONUT_FIVE = 5ul;
const DWORD MPLUSCFW_WCHARARRAY_SIZE = 16ul;
const DWORD MPLUSCFW_MAX_FORMAT_NAME_LEN = 256ul;
const DWORD MPLUSCFW_THREADWAIT_TIMEOUT = 0ul;
const DWORD MPLUSCFW_RECEIVEMESSAGE_TIMEOUT = 0ul;

// Abort flag constant
const DWORD MPLUSCFW_C_DWORD_FLAGFALSE = 0ul;
const DWORD MPLUSCFW_C_DWORD_FLAGTRUE = 1ul;

// WeiXueyuan modify start on 2009-2-3
// ProjectID: TMS604
// BugSource: RC
// BugID:  RC
// BugReason: ASync I/O
// FixSolution: Use ASync I/O
/**
 * A core thread to receive messages
 * @param     pParam: transfer to pointer of InnerConnector class
 * @return    UINT: check whether it returns normally
 * @since     1.00
 */
UINT InnerConnector::WatchThread( LPVOID pParam )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::WatchThread") );
    // PParam should contain valid data
    InnerConnector* pConnector = reinterpret_cast<InnerConnector*>( pParam );
    if ( NULL == pConnector )
    {
        return MPLUSCFW_ERROR_WATCHTHREAD_RETURN;
    }

    // Initialize receive action
    DWORD dwAction = static_cast<DWORD>( MQ_ACTION_RECEIVE );    
    OVERLAPPED * poverlapped = NULL;
    try
    {        
        UINT64 dwPreviousID = MPLUSCFW_CONST_ZERO;        
        HANDLE hWaitHandle[WAITOBJECTCOUNT];
        hWaitHandle[FIRSTOBJECT] = NULL;
        hWaitHandle[SECONDOBJECT] = NULL;
        // the event for exit receive message
        hWaitHandle[FIRSTOBJECT] = pConnector->m_hExitEvent;
        if ( NULL == hWaitHandle[FIRSTOBJECT] )
        {
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T( "WatchThread" );
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( MPLUSCFW_ERROR_WATCHTHREAD_RETURN, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return MPLUSCFW_ERROR_WATCHTHREAD_RETURN;
        }
        poverlapped = new OVERLAPPED;
        if ( poverlapped == NULL )
        {   
            return MPLUSCFW_ERROR_WATCHTHREAD_RETURN;
        }
        poverlapped->hEvent = CreateEvent( NULL,TRUE,FALSE,NULL );
        // the event for get message
        hWaitHandle[SECONDOBJECT] = poverlapped->hEvent;           
        if ( NULL == hWaitHandle[SECONDOBJECT] )
        {
            if ( NULL != poverlapped )
            {
                delete poverlapped;
                poverlapped = NULL;
            }
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T( "WatchThread" );
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( MPLUSCFW_ERROR_WATCHTHREAD_RETURN, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return MPLUSCFW_ERROR_WATCHTHREAD_RETURN;
        }
        //loop for receive message
        while ( true )
        {
             HRESULT hr = S_FALSE;
             _bstr_t bstrMsg( MPLUSCFW_EMPTY_STRING );
             _bstr_t bstrLabel( MPLUSCFW_EMPTY_STRING );
             // yutianyi add start on 2010-06-09 for Change Record CFW003&004&005&006
             _bstr_t strPreviousFromQueueName ( MPLUSCFW_EMPTY_STRING );
             // yutianyi add end on 2010-06-09 for Change Record CFW003&004&005&006
             // yutianyi add start on 2010-06-22 for Change Record CFW005
             _bstr_t strPreviousHostName ( MPLUSCFW_EMPTY_STRING );
             // yutianyi add end on 2010-06-22 for Change Record CFW005
             // yutianyi add start on 2010-07-14 for Change Record CFW005
             _bstr_t bstrFormatName = _bstr_t( MPLUSCFW_EMPTY_STRING );
             // yutianyi add end on 2010-07-14 for Change Record CFW005
             // yutianyi add start on 2010-07-23 for Change Record CFW003&004&005&006
             _bstr_t bstrPreSessionId = _bstr_t( MPLUSCFW_EMPTY_STRING );
             // yutianyi add end on 2010-07-23 for Change Record CFW003&004&005&006
            // Lock to prevent others receive message
            //pConnector->m_RecvLock.Lock();
             // yutianyi modify start on 2010-07-14 for Change Record CFW005
            /*hr = pConnector->ReadQueue( pConnector->m_hRecvQueue,                
                pConnector->m_hExitEvent,
                &bstrLabel,
                &bstrMsg,
                dwAction,
                poverlapped );*/      
             hr = pConnector->ReadQueue( pConnector->m_hRecvQueue,                
                 pConnector->m_hExitEvent,
                 pConnector->m_hThreadStartEvent,
                 &bstrLabel,
                 &bstrFormatName,
                 &bstrMsg,
                 dwAction,
                 poverlapped );
            // yutianyi modify end on 2010-07-14 for Change Record CFW005
            //pConnector->m_RecvLock.Unlock();
            // S_FALSE means exit event is signaled
            if ( S_FALSE == hr )
            {
                break;
            }
            if ( SUCCEEDED(hr) )
            {
                // [XueKang] [add] start on 2008-12-4
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW trace log more clear
                // FixSolution: add more trace log info  for sending/receiving message
                // Following trace log is needed for display MPLUS_TRACE_P2P_RECEIVE in the below
                MPLUS_TRACE_FUNC_IN( _T("InnerConnector::WatchThread GetMessageSuccess"));
                // [XueKang] [add] end on 2008-12-4
                
                // Is the message version right?
                MPlusMessage msgIn;
                if ( pConnector->ParaseVersion( bstrLabel ) !=
                    MPLUSCFW_COMM_VERSION )
                {                    
                    continue;
                }
                
                // Decode the message
                if ( false == pConnector->DeserializeMsg( bstrMsg, &msgIn ))
                {
                    // Error process
                    continue;
                }

                // yutianyi add start on 2010-07-14 for Change Record CFW005
                CString csFormatName = static_cast<LPCTSTR>(bstrFormatName);
                if ( csFormatName.GetLength() != 0 )
                {
                    CString csHostName = MPLUSCFW_EMPTY_STRING;
                    CString csQName = MPLUSCFW_EMPTY_STRING;
                    CString csSessionId = MPLUSCFW_EMPTY_STRING;
                    int n = csFormatName.Find('\\');
                    csHostName = csFormatName.Left( n );
                    csHostName = csHostName.Right( csHostName.GetLength() - 10 );
                    n = csFormatName.ReverseFind('\\');
                    csQName = csFormatName.Right( csFormatName.GetLength() - n - 1 );
                    n = csQName.ReverseFind('_');
                    if(n < 0)
                    {
                        csSessionId = MPLUSCFW_EMPTY_STRING;
                    }
                    else
                    {
                        csSessionId = csQName.Right( csQName.GetLength() - n - 1 );
                        csQName = csQName.Left( n );
                    }
                    //Add the following code
                    if (!csQName.IsEmpty())
                    {
                        msgIn.SetFromAddress( (_bstr_t)csQName );
                        msgIn.SetSessionId( (_bstr_t)csSessionId );
                        msgIn.SetHostName( (_bstr_t)csHostName );
                    }                
                }
                // yutianyi add end on 2010-07-14 for Change Record CFW005
                
                // Make sure the message ID is valid
                if ( MPLUSCFW_CONST_ZERO == msgIn.GetUID())
                {
                    // Error process
                    continue;
                }

                // [XueKang] [add] start on 2008-11-25
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW trace log more clear
                // FixSolution: add more trace log info  for sending/receiving message 
                DWORD dwCallType = msgIn.GetCallType();
                UINT64 uReUid = msgIn.GetReUID();
                TCHAR output[OUTPUTMAXLEN];
                if (( CFW_CALLTYPE_SYNC == dwCallType ) &&
                    (( uReUid != pConnector->m_uUidForSyncMessage) || ( uReUid == 0 )))
                {
                    // receive sync message
                    _sntprintf( output, OUTPUTMAXLEN, _T( "[RecvSync] SenderName:%s, \
                        SenderQName:%s ReceiverQName:%s Command:%s\n \
                        Parameter:%s, Custom:%s\n \
                        UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
                        ( LPCTSTR )msgIn.GetSender(), 
                        ( LPCTSTR )msgIn.GetFromAddress(),
                        ( LPCTSTR )msgIn.GetToAddress(),
                        ( LPCTSTR )msgIn.GetCommand(),
                        ( LPCTSTR )msgIn.GetParameter(),
                        ( LPCTSTR )msgIn.GetCustom(),
                        msgIn.GetUID(), msgIn.GetReUID(),msgIn.GetTimeOut());
                    MPLUS_TRACE_P2P_RECEIVE( output );
                }
                else if ( CFW_CALLTYPE_ASYNC == dwCallType )
                {
                    // receive Async message
                    _sntprintf( output, OUTPUTMAXLEN, _T( "[RecvASync] SenderName:%s, \
                        SenderQName:%s ReceiverQName:%s Command:%s\n \
                        Parameter:%s, Custom:%s\n \
                        UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
                        ( LPCTSTR )msgIn.GetSender(), 
                        ( LPCTSTR )msgIn.GetFromAddress(),
                        ( LPCTSTR )msgIn.GetToAddress(),
                        ( LPCTSTR )msgIn.GetCommand(),
                        ( LPCTSTR )msgIn.GetParameter(),
                        ( LPCTSTR )msgIn.GetCustom(),
                        msgIn.GetUID(), msgIn.GetReUID(),msgIn.GetTimeOut());
                    MPLUS_TRACE_P2P_RECEIVE( output );
                }  
                // [XueKang] [add] end on 2008-11-25

                // Make sure we don't receive a duplicated message
                // yutianyi modify start on 2010-06-09 for Change Record CFW003&004&005&006
                // yutianyi modify start on 2010-06-22 for Change Record CFW005
                //if ( dwPreviousID != msgIn.GetUID() || strPreviousFromQueueName != msgIn.GetFromAddress() )
                if ( dwPreviousID != msgIn.GetUID() || 
                    strPreviousFromQueueName != msgIn.GetFromAddress() ||
                    bstrPreSessionId != msgIn.GetSessionId() || 
                    strPreviousHostName != msgIn.GetHostName())
                // yutianyi modify end on 2010-06-22 for Change Record CFW0005
                {
                    strPreviousFromQueueName = msgIn.GetFromAddress();
                    dwPreviousID = msgIn.GetUID();
                    bstrPreSessionId = msgIn.GetSessionId();
                    // yutianyi add start on 2010-06-22 for Change Record CFW005
                    strPreviousHostName = msgIn.GetHostName();
                    if ( msgIn.GetCommand() == 
                        _bstr_t( MPLUSCFW_CHECK_QUEUE_MESSAGE ) || 
                        msgIn.GetCommand() == 
                        _bstr_t( MPLUSCFW_BCMSGTYPE_QUERYHOSTINFO ))
                    {
                        if ((( uReUid == pConnector->m_uUidForSyncMessage ) && ( uReUid != 0 )))
                        {
                            // Receive Reply_sync message

                            // set uid of last sent sync msg to zero 
                            pConnector->m_uUidForSyncMessage = 0;                            
                            if ( NULL == pConnector->m_pMessageRet )
                            {
                                // if user don't want to get reply message content
                                continue;
                            }
                            else if ( pConnector->m_bSendSyncMsg == true )
                            {
                                // if user want to get the reply message content
                                pConnector->m_bSendSyncMsg = false;
                                msgIn.Clone( pConnector->m_pMessageRet );    
                            }
                            if ( NULL == pConnector->m_hSendSyncEvent )
                            {
                                continue;
                            }
                            else
                            {
                                // inform SyncMsg sender that get the reply
                                SetEvent( pConnector->m_hSendSyncEvent );                                                                     
                                continue;
                            }                                
                        }
                        // Have return command
                        if ( pConnector->GetEnableReply() )
                        {
                            pConnector->ReplyCheckMsg( &msgIn );
                            continue;
                        }
                    }
                    // yutianyi add end on 2010-06-22 for Change Record CFW005
                    
                    // Notify user we have got a message
                    if ( NULL != pConnector->m_pCallBack )
                    {
                        if ( pConnector->m_bSendMultiMsg && pConnector->m_bSendSyncMsg )
                        {
                            bool bGetAllReply = true;
                            bool bIsSycMsg =false;
                            
                            for ( UINT i = 0; i < pConnector->m_validQueueArr.size(); i++ )
                            {   // ensure this is a reply sync msg 
                                if ( uReUid == pConnector->m_validQueueArr[i].uUid && ( uReUid != 0 ) )
                                {
                                     pConnector->m_validQueueArr[i].bState = true;
                                     bIsSycMsg = true;
                                     // if any receiver send success send process is OK;
                                     pConnector->m_bSendSyncPartOK = true;
                                }
                                if ( !pConnector->m_validQueueArr[i].bState )
                                {
                                    bGetAllReply = false;
                                }
                            }
                            if ( NULL == pConnector->m_hSendSyncEvent )
                            {
                                continue;
                            }
                            else if ( bGetAllReply )
                            {
                                pConnector->m_bSendSyncMsg = false;
                                msgIn.Clone( pConnector->m_pMessageRet ); 
                                // trace log for receive Reply_sync message
                                TCHAR output[OUTPUTMAXLEN];
                                _sntprintf( output, OUTPUTMAXLEN, 
                                    _T( "[RecvReply] SenderName:%s, \
                                        SenderQName:%s ReceiverQName:%s Command:%s\n \
                                        Parameter:%s, Custom:%s\n \
                                        UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
                                        ( LPCTSTR )msgIn.GetSender(), 
                                        ( LPCTSTR )msgIn.GetFromAddress(),
                                        ( LPCTSTR )msgIn.GetToAddress(), 
                                        ( LPCTSTR )msgIn.GetCommand(),
                                        ( LPCTSTR )msgIn.GetParameter(), 
                                        ( LPCTSTR )msgIn.GetCustom(),
                                        msgIn.GetUID(), msgIn.GetReUID(),
                                        msgIn.GetTimeOut());
                                MPLUS_TRACE_P2P_RECEIVE( output );
                                // inform SyncMsg sender that get the reply
                                SetEvent( pConnector->m_hSendSyncEvent );  
                                //pConnector->m_bSendMultiMsg = false;
                                continue;
                            }
                            else
                            {
                                if(bIsSycMsg == true)
                                {
                                    continue;
                                }
                                else
                                {
                                    ;
                                }
                            }
                        }
                        else
                        {
                            if ((( uReUid == pConnector->m_uUidForSyncMessage ) && ( uReUid != 0 )))
                            {
                                // Receive Reply_sync message

                                // set uid of last sent sync msg to zero 
                                pConnector->m_uUidForSyncMessage = 0;                            
                                if ( NULL == pConnector->m_pMessageRet )
                                {
                                    // if user don't want to get reply message content
                                    continue;
                                }
                                else if ( pConnector->m_bSendSyncMsg == true )
                                {
                                    // if user want to get the reply message content
                                    pConnector->m_bSendSyncMsg = false;
                                    msgIn.Clone( pConnector->m_pMessageRet );    
                                }
                                if ( NULL == pConnector->m_hSendSyncEvent )
                                {
                                    continue;
                                }
                                else
                                {
                                    // trace log for receive Reply_sync message
                                    TCHAR output[OUTPUTMAXLEN];
                                    _sntprintf( output, OUTPUTMAXLEN, 
                                        _T( "[RecvReply] SenderName:%s, \
                                            SenderQName:%s ReceiverQName:%s Command:%s\n \
                                            Parameter:%s, Custom:%s\n \
                                            UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
                                            ( LPCTSTR )msgIn.GetSender(), 
                                            ( LPCTSTR )msgIn.GetFromAddress(),
                                            ( LPCTSTR )msgIn.GetToAddress(), 
                                            ( LPCTSTR )msgIn.GetCommand(),
                                            ( LPCTSTR )msgIn.GetParameter(), 
                                            ( LPCTSTR )msgIn.GetCustom(),
                                            msgIn.GetUID(), msgIn.GetReUID(),
                                            msgIn.GetTimeOut());
                                    MPLUS_TRACE_P2P_RECEIVE( output );
                                    // inform SyncMsg sender that get the reply
                                    SetEvent( pConnector->m_hSendSyncEvent );                                                                     
                                    continue;
                                }                                
                            }
                        }
                        // yutianyi modify end on 2010-06-09 for Change Record CFW003&004&005&006
                        // receive sync or asyncmessage 
                        MPlusMessage msgOut;
                        BOOL bReply = pConnector->m_pCallBack(
                            &msgIn, &msgOut, pConnector->m_pCustom );
                        
                        // Have return command
                        if (( TRUE == bReply ) && pConnector->GetEnableReply())
                        {
                            ::MPLUS::FW::COMM::SendReplyMsg( &msgIn, &msgOut );
                        }
                    }                    
                }
            }            
            else if ( ERROR_CFW_MESSAGE_ALREADY_RECEIVED == hr )
            {  
                continue;
            }            
            // The queue already not exists
            else if ( ERROR_CFW_CHANNEL_NOT_EXIST == hr )
            {
                // An empty message means error happens.
                // Notify the application: lost connection
                if ( NULL != pConnector->m_pCallBack )
                {
                    MPlusMessage msgEmpty;
                    pConnector->m_pCallBack( &msgEmpty,
                        &msgEmpty, pConnector->m_pCustom );
                }
                
                // Stop listen and exit
                // WeiXueyuan modify start on 2008-12-15
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info                
                HRESULT hRes = pConnector->UnListen();
                if (FAILED(hRes))
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T( "RecvP2PMsg" );
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp,
                        MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, 
                        ( LPCTSTR )pConnector->m_bstrRecvQ, 
                        MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
                }
                // weixueyuan modify end on 2008-12-15
                // WeiXueyuan add start on 2008-12-11
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info
                ErrorDetail stErrorDetail;
                CString cTemp = _T( "RecvP2PMsg" );
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, 
                    MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, 
                    ( LPCTSTR )pConnector->m_bstrRecvQ, 
                    MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( hr, stErrorDetail );
                // weixueyuan add end on 2008-12-11
                break;
            }            
            // Time out
            else if ( ERROR_CFW_IO_TIMEOUT == hr )
            {
                continue;
            }            
            // Other errors
            else
            {
                // WeiXueyuan add start on 2008-12-4
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info
                ErrorDetail stErrorDetail;
                CString cTemp = _T( "RecvP2PMsg" );
                CFW_COPY_STRING( stErrorDetail.cCondition, 
                    cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, 
                    ( LPCTSTR )pConnector->m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_RECV, stErrorDetail );
                // weixueyuan add end on 2008-12-4
                if ( NULL != poverlapped )
                {
                    if ( NULL != poverlapped->hEvent )
                    {
                        ::CloseHandle( poverlapped->hEvent );
                        poverlapped->hEvent = NULL;
                    }
                    delete poverlapped;
                    poverlapped = NULL;
                }
                return MPLUSCFW_ERROR_WATCHTHREAD_RETURN;
                // [XueKang] [modify] end on 2008-08-21
            }
        }// for while
    }// for try
    catch(...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        ErrorDetail stErrorDetail;
        CString cTemp = _T( "RecvP2PMsg" );
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, 
            (LPCTSTR)pConnector->m_bstrRecvQ, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // weixueyuan add end on 2008-12-4
        if ( NULL != poverlapped )
        {
            if ( NULL != poverlapped->hEvent )
            {
                ::CloseHandle( poverlapped->hEvent );
                poverlapped->hEvent = NULL;
            }
            delete poverlapped;
            poverlapped = NULL;
        }
        return MPLUSCFW_ERROR_WATCHTHREAD_RETURN;
    }
    if ( NULL != poverlapped )
    {
        if ( NULL != poverlapped->hEvent )
        {
            ::CloseHandle( poverlapped->hEvent );
            poverlapped->hEvent = NULL;
        }
        delete poverlapped;
        poverlapped = NULL;
    }
    return MPLUSCFW_CONST_ZERO;
}

// yangke delete start on 20101025 for directory structure change
/*
/**
 * Serialize message that is waiting for sending
 * @param     pMsg: message
 * @return    _bstr_t: result of serializing
 * @since     1.00
_bstr_t InnerConnector::SerializeMsg( IMplusMessage* pMsg )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SerializeMsg") );
    try
    {
        // TraceOutPut( _T("Start InnerConnector::SerializeMsg()") );
        // Check message whether is NULL
        if ( NULL == pMsg )
        {
            // If it's NULL, return empty message
            return _bstr_t( MPLUSCFW_EMPTY_STRING );
        }
        // Correct message is serialized
        MsgSerializer serializer( pMsg );
        _bstr_t bstrRet( serializer.Serialize(), false );
        
        //TraceOutPut( _T("End InnerConnector::SerializeMsg()") );
        
        return bstrRet;
    }
    // If method throws exception, catch it
    catch (...)
    {
        return _bstr_t ( MPLUSCFW_EMPTY_STRING );
    }
}
*/
/*
/**
 * Parse the received message
 * @param     bstrMsg: Message body to be decoded.
 * @param     pMsg: Message buffer to receive the decoded message.
 * @return    bool: Does the operation succeeded.
 * @since     1.00
 */
/*
bool InnerConnector::DeserializeMsg( const _bstr_t &bstrMsg,
                                     IMplusMessage *pMsg )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::DeserializeMsg") );
    try
    {
        if ( NULL == pMsg )
        {
            return false;
        }
        MsgSerializer serializer( pMsg );
        return serializer.DeSerialize( bstrMsg );
    }
    catch (...)
    {
        return false;
    }
}
*/
// yangke delete end on 20101025 for directory structure change

/**
 * Construction function of the InnerConnector
 * @param     void
 * @return    void
 * @since     1.00
 */
InnerConnector::InnerConnector(bool bFlag):
// pgq modified start on 2010-11-02 for CPP Test
    m_bDummyFlag(false),
    m_bSendSyncPartOK(false)
// pgq modified end on 2010-11-02 for CPP Test
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::InnerConnector(bool bFlag)") );
    m_bDummyFlag = bFlag;
}

/**
 * Construction function of the InnerConnector
 * @param     void
 * @return    void
 * @since     1.00
 */
InnerConnector::InnerConnector():
// pgq modified start on 2010-11-02 for CPP Test
    m_bDummyFlag(false),
    m_bSendSyncPartOK(false)
// pgq modified end on 2010-11-02 for CPP Test
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::InnerConnector") );

    HRESULT hr = ::CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if (hr == S_OK || hr == S_FALSE)
    {
        m_bInitCom = true;
    }
    else if (hr == RPC_E_CHANGED_MODE)
    {
        // yangke modified start on 2010-9-29 for code review log
        //ErrorDetail stErrorDetail;
        //CString cTemp = _T("InnerConnector");
        //CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        //CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAIL_COINITIALIZE, 
        //    stErrorDetail );
        //CFW_OUTPUT_WARNING( ERROR_CFW_FAIL_COINITIALIZE );
        hr = ::CoInitializeEx( NULL, COINIT_APARTMENTTHREADED);
        if (hr == S_OK || hr == S_FALSE)
        {
            m_bInitCom = true;
        }
        else
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("InnerConnector");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAIL_COINITIALIZE, 
                stErrorDetail );
        }
        // yangke modified end on 2010-9-29 for code review log
    }
    else
    {
        ErrorDetail stErrorDetail;
        CString cTemp = _T("InnerConnector");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAIL_COINITIALIZE, 
            stErrorDetail );
    }

    HRESULT hRet = m_pQMLAccess.CoCreateInstance( BCMANAGER_QMLACCESS );
    if(FAILED(hRet) || m_pQMLAccess == NULL)
    {
        ErrorDetail stErrorDetail;
        CString cTemp = _T("InnerConnector");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAIL_INITIALIZE_COM, 
            stErrorDetail );
    }
    m_bDummyFlag = false;
}
// yangke delete start on 20101025 for directory structure change
/*
/**
 * Set it whether could reply message
 * @param     bCanReply: value that wants to be set
 * @return    bool: value of previous time
 * @since     1.00
*/
/*
bool InnerConnector::SetEnableReply( bool bCanReply )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SetEnableReply") );
    bool bOrg = m_bCanReply;
    m_bCanReply = bCanReply;
    return bOrg;
}
*/

/**
 * Get a signal that it's able to reply
 * @param     void
 * @return    bool: Whether the connector reply the synchronized message.
 * @since     1.00
*/
/*
bool InnerConnector::GetEnableReply()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::GetEnableReply") );
    return m_bCanReply;
}
// yangke delete end on 20101025 for directory structure change

/**
 * Destructor of the InnerConnector
 * @param     void
 * @return    void
 * @since     1.00
 */
InnerConnector::~InnerConnector()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::~InnerConnector") );
    // Catch exception
    try
    {
        if(!m_bDummyFlag)
        {
            // We should clean up the connection
            if ( IsConnected())
            {
                DisConnect();
            }
            if ( m_hRecvQueue ) // release resources
            {
                UnListen();
            }
            // yangke modified start on 2010-9-28 for code review log
            if(m_bInitCom )
            {
                ::CoUninitialize();
            }
        }
        else
        {
            // do nothing
            ;
        }
        // yangke  modified end on 2010-9-28 for code review log
        // yutianyi add end on 2010-09-15 for Change Record CFW005
    }

    // Exception handling
    catch (...)
    {
        // Any exceptions should be caught here
        // sunyongjie add start on 20101018 for tch review log
        ErrorDetail stErrorDetail;
        CString cTemp = _T("~InnerConnector");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // sunyongjie add end on 20101018 for tch review log
        return;
    }
}

/**
 * Check whether the queue is active
 * @param     bstrName: name of target queue
 * @return    bool: Is the queue active.
 * @since     1.00
 */
bool InnerConnector::IsQueueActive( const _bstr_t& bstrName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::IsQueueActive") );
    bool bRet = true;

    try
    {
        QUEUEHANDLE hQueue = NULL;
        // Test to see if we can open the queue with receive access
        HRESULT hr = OpenQueue( bstrName, hQueue, MQ_RECEIVE_ACCESS, true );

        // Nobody is listening this queue
        if ( SUCCEEDED( hr ))
        {
            // We can open it means no body deny the receive access
            bRet = false;
            ::MQCloseQueue( hQueue );
        }
        return bRet;
    }
    // If method throws exception, catch it
    catch ( ... )
    {
        return bRet;
    }
}

/**
 * Connect to a queue
 * @param     bstrName: name of target queue
 * @param     bCreate: whether create a queue
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
// yutianyi modify start on 2010-06-18 for Change Record CFW003&004&005&006
//HRESULT InnerConnector::Connect( const _bstr_t& bstrName, bool bCreate )
HRESULT InnerConnector::Connect( const _bstr_t& bstrName, 
                const _bstr_t bstrSessionID, 
                const _bstr_t bstrHostName, 
                bool bCreate )
// yutianyi modify end on 2010-06-18 for Change Record CFW003&004&005&006
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::Connect") );
    try
    {
        // yutianyi add start on 2010-06-22 for Change Record CFW005
        bool bPartOK = false;
        // yangke modified start on 2010-9-28 for AT bug
        CString csHostName = (LPCTSTR)bstrHostName;
        CString csMyHostName = (LPCTSTR)m_bstrMyHostName;
        m_pMessageRet = NULL;
        //if ( bstrHostName == _bstr_t(MPLUSCFW_EMPTY_STRING) || 
        //    bstrHostName == m_bstrMyHostName )
        if ( csHostName.CompareNoCase(_T(""))==0 || 
            csHostName.CompareNoCase(csMyHostName)==0 )
        // yangke  modified end on 2010-9-28 for AT bug

        {
        // yutianyi add end on 2010-06-22 for Change Record CFW005
            // yutianyi add start on 2010-07-14 for Change Record CFW003&004&005&006
            // create new queue name with session id
            _bstr_t bstrFullName = _bstr_t( MPLUSCFW_EMPTY_STRING );
            bool bSendMultiMsg = false;

            m_validQueueArr.clear();
            CStringArray csArrQueueName;
            // current session
            if ( bstrSessionID == _bstr_t( MPLUSCFW_EMPTY_STRING ) )
            {
                DWORD dwCurrentSessionID;
                ::ProcessIdToSessionId( ::GetCurrentProcessId(), &dwCurrentSessionID );
                CString csSessionId( MPLUSCFW_EMPTY_STRING );
                csSessionId.Format( _T("%d"), dwCurrentSessionID );
                _bstr_t strSessionId( csSessionId );
                bstrFullName = bstrName + _bstr_t(MPLUSCFW_CONNCT_CHARACTER) + strSessionId;
            }// session ID is *
            else if ( bstrSessionID == _bstr_t( MPLUSCFW_SESSIONID_STAR ) )
            {
                bSendMultiMsg = true;
                // find all queue names
                HRESULT hr = GetAllQueueNames( bstrName, bstrHostName, csArrQueueName );
                if ( FAILED( hr ) || csArrQueueName.GetSize() == 0 )
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, 
                        stErrorDetail );
                    return ERROR_CFW_LIST_ALL_SESSIONIDS;
                }
            }// specified session ID
            else
            {
                bstrFullName = bstrName + MPLUSCFW_CONNCT_CHARACTER + bstrSessionID;
            }

            if ( bSendMultiMsg )
            {
                // [TCH_Li Jinguo] [add] start on 2010-10-18
                // BugReason: Make sure CFW source code of MPlus V5 can be compliled by Visual C++ 6.0
                // FixSolution: define variable ahead of time 
                int i=0;
				// [TCH_Li Jinguo] [add] end on 2010-10-18
                for ( i = 0; i < csArrQueueName.GetSize(); i++ )
                {
                    if ( !IsValidQueueName( _bstr_t(csArrQueueName.GetAt(i)) ))
                    {
                        ErrorDetail stErrorDetail;
                        CString cTemp = _T("Connect");
                        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)csArrQueueName.GetAt(i), MAX_LENGTH - InitOne );
                        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                            stErrorDetail );
                        // weixueyuan add end on 2008-12-4
                        return ERROR_CFW_INVALID_PARAMETERS;
                    }
                }

                DisConnect();
                QUEUEHANDLE hSendQueue;
                HRESULT hr = S_OK;
                bool bStatus = false;
                for ( i = 0; i < csArrQueueName.GetSize(); i++ )
                {
                    hr = OpenQueue( _bstr_t(csArrQueueName.GetAt(i)),
                        hSendQueue, MQ_SEND_ACCESS, !bCreate );
                    // valid handles and queue names
                    if(SUCCEEDED(hr))
                    {
                        bStatus = true;

                        QUEUEITEM_t temp;
                        temp.bState=false;
                        temp.bstrQueueName = csArrQueueName.GetAt(i);
                        temp.hQueueHandle = hSendQueue;
                        temp.uUid = 0;
                        m_validQueueArr.push_back(temp);
                    }
                }
                if ( FAILED( hr ) && !bStatus )
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    //CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)csArrQueueName.GetAt(i), MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hr, 
                        stErrorDetail );
                    return hr;
                }
            }
            else
            {   
                // can't connect to itself
                CString csHostName = (LPCTSTR)bstrHostName;
                CString csMyHostName = (LPCTSTR)m_bstrMyHostName;
                CString csFullName = (LPCTSTR)bstrFullName;
                CString csRecvQ = (LPCTSTR)m_bstrRecvQ;
                 // yangke modified start on 2010-9-28 for AT bug
                //if ( bstrFullName == m_bstrRecvQ && 
                //    (bstrHostName == m_bstrMyHostName || 
                //    bstrHostName == _bstr_t(MPLUSCFW_EMPTY_STRING)))
                if(csFullName.CompareNoCase(csRecvQ)==0 &&
                    (csHostName.CompareNoCase(csMyHostName)==0 ||
                   csHostName.CompareNoCase(MPLUSCFW_EMPTY_STRING)==0) )
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_CANNOT_CONNECT_ITSELF, stErrorDetail );
                    return ERROR_CFW_CANNOT_CONNECT_ITSELF;
                }
                 // yangke modified end on 2010-9-28 for AT bug
                // yutianyi add end on 2010-07-14 for Change Record CFW003&004&005&006

                if ( !IsValidQueueName( bstrFullName ))
                {
                    // WeiXueyuan add start on 2008-12-4
                    // ProjectID: TMS585
                    // BugSource: RC
                    // BugID:  RC
                    // BugReason: Make CFW event log more clear
                    // FixSolution: add more event log info
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                        stErrorDetail );
                    // weixueyuan add end on 2008-12-4
                    return ERROR_CFW_INVALID_PARAMETERS;
                }

                DisConnect();

                HRESULT hr = OpenQueue( bstrFullName, m_hSendQueue,
                                        MQ_SEND_ACCESS, !bCreate );
                if ( FAILED( hr ))
                {
                    // WeiXueyuan add start on 2008-12-12
                    // ProjectID: TMS585
                    // BugSource: RC
                    // BugID:  RC
                    // BugReason: Make CFW event log more clear
                    // FixSolution: add more event log info
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hr, 
                        stErrorDetail );
                    // weixueyuan add end on 2008-12-12
                    return hr;
                }

                m_bstrSendQ = bstrFullName;
            }
            m_bSendMultiMsg = bSendMultiMsg;
            m_bstrTargetHostName = m_bstrMyHostName;
            return S_OK;
        }
        // yutianyi add start on 2010-06-22 for Change Record CFW005
        // accross host
        else
        {
            // yutianyi add start on 2010-09-15 for Change Record CFW005
            //need receive some inside message we must ensure has a receive queue X.
            bool bCurrentListenStatus = IsListening();
            if(false == bCurrentListenStatus)
            {
                //this queue only recv inside message after received delete it.
                CString csTempRecvQueue = BuildGUIDQueueName();
                ::ResetEvent(m_hThreadStartEvent);
                ListenForTempQueue(_bstr_t(csTempRecvQueue));
                WaitForSingleObject(m_hThreadStartEvent,INFINITE);
            }
            // yutianyi add end on 2010-09-15 for Change Record CFW005
            _bstr_t bstrFullName = _bstr_t( MPLUSCFW_EMPTY_STRING );
            bool bSendMultiMsg = false;

            //m_validQueueArr.clear();
            DisConnect();
            CStringArray csArrQueueName;
            if ( bstrSessionID == _bstr_t( MPLUSCFW_EMPTY_STRING ) )
            {           
                //delete temp queue X.
                if(false == bCurrentListenStatus)
                {
                    UnListen();
                }
                // sunyongjie add start on 20101018 for tmsc review log
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Connect");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                    stErrorDetail );
                // sunyongjie add end on 20101018 for tmsc review log
                return ERROR_CFW_INVALID_PARAMETERS;
            }
            else if ( bstrSessionID == _bstr_t( MPLUSCFW_SESSIONID_STAR ) )
            {
                // yutianyi add start on 2010-07-05 for Change Record CFW003&004&005&006
                bSendMultiMsg = true;
                HRESULT hr = GetAllQueueNames( bstrName, bstrHostName, csArrQueueName );
                if ( FAILED( hr ) || csArrQueueName.GetSize() == 0 )
                {
                    //delete temp queue X.
                    if(false == bCurrentListenStatus)
                    {
                        UnListen();
                    }
                    // sunyongjie add start on 20101018 for tmsc review log
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, 
                        stErrorDetail );
                    // sunyongjie add end on 20101018 for tmsc review log
                    return ERROR_CFW_LIST_ALL_SESSIONIDS;
                }
                // yutianyi add end on 2010-07-05 for Change Record CFW003&004&005&006
            }
            else
            {
                bstrFullName = bstrName + MPLUSCFW_CONNCT_CHARACTER + bstrSessionID;
            }

            if ( bSendMultiMsg )
            {
                // [TCH_Li Jinguo] [add] start on 2010-10-18
                // BugReason: Make sure CFW source code of MPlus V5 can be compiled by Visual C++ 6.0
                // FixSolution: define variable ahead of time 
                int i=0;
				// [TCH_Li Jinguo] [add] end on 2010-10-18
                for ( i = 0; i < csArrQueueName.GetSize(); i++ )
                {
                    if ( !IsValidQueueName( _bstr_t(csArrQueueName.GetAt(i)) ))
                    {
                        ErrorDetail stErrorDetail;
                        CString cTemp = _T("Connect");
                        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)csArrQueueName.GetAt(i), MAX_LENGTH - InitOne );
                        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                            stErrorDetail );
                        //delete temp queue X.
                        if(false == bCurrentListenStatus)
                        {
                            UnListen();
                        }
                        return ERROR_CFW_INVALID_PARAMETERS;
                    }
                }

                DisConnect();
                QUEUEHANDLE hSendQueue;
                HRESULT hr = S_OK;
                bool bStatus = false;
                
                for ( i = 0; i < csArrQueueName.GetSize(); i++ )
                {
                    hr = OpenQueue( _bstr_t(csArrQueueName.GetAt(i)),
                        hSendQueue, MQ_SEND_ACCESS, !bCreate, bstrHostName );

                    if ( SUCCEEDED( hr ))
                    {   // everytime openqueue across host, need to check
                        hr = SendSyncMessToCheckQueue( hSendQueue, _bstr_t(csArrQueueName.GetAt(i)) );
                        if ( SUCCEEDED( hr ))
                        {
                            bStatus = true;

                            QUEUEITEM_t temp;
                            temp.bState=false;
                            temp.bstrQueueName = csArrQueueName.GetAt(i);
                            temp.hQueueHandle = hSendQueue;
                            temp.uUid = 0;
                            m_validQueueArr.push_back(temp);
                        }
                        else 
                        {   // partly OK 
                            bPartOK = true;
                        }
                    }
                }
                if ( !bStatus )
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    //CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)csArrQueueName.GetAt(i), MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hr, 
                        stErrorDetail );
                    //delete temp queue X.
                    if(false == bCurrentListenStatus)
                    {
                        UnListen();
                    }
                    return hr;
                }
            }
            else
            {
                if ( !IsValidQueueName( bstrFullName ))
                {  
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                        stErrorDetail );
                    //delete temp queue X.
                    if(false == bCurrentListenStatus)
                    {
                        UnListen();
                    }
                    return ERROR_CFW_INVALID_PARAMETERS;
                }

                DisConnect();

                QUEUEHANDLE hSendQueue = NULL;
                HRESULT hr = OpenQueue( bstrFullName, hSendQueue,
                    MQ_SEND_ACCESS, !bCreate, bstrHostName );
                if ( FAILED( hr ))
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hr, stErrorDetail );
                    //delete temp queue X.
                    if(false == bCurrentListenStatus)
                    {
                        UnListen();
                    }
                    return hr;
                }

                hr = SendSyncMessToCheckQueue( hSendQueue, bstrFullName );
                if ( FAILED( hr ))
                {
                    ::MQCloseQueue( hSendQueue );
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Connect");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hr, stErrorDetail );
                    //delete temp queue X.
                    if(false == bCurrentListenStatus)
                    {
                        UnListen();
                    }
                    return hr;
                }

                m_hSendQueue = hSendQueue;
                m_bstrSendQ = bstrFullName;
            }
            m_bSendMultiMsg = bSendMultiMsg;
            m_bstrTargetHostName = bstrHostName;
            //delete temp queue X.
            if(false == bCurrentListenStatus)
            {
                UnListen();
            }
            
            if(bPartOK)
            {
                return S_FALSE;
            }
            else
            {
                return S_OK;
            }
            
        }
        // yutianyi add end on 2010-06-22 for Change Record CFW005
    }
    catch (...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        ErrorDetail stErrorDetail;
        CString cTemp = _T("Connect");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, 
            stErrorDetail );
        // weixueyuan add end on 2008-12-4

        return ERROR_CFW_UNKNOWN_ERROR;
    }
}

/**
 * Disconnect with a connected queue
 * @param     void
 * @return    HRESULT: A error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::DisConnect()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::DisConnect") );
    try
    {
        // yutianyi modify start on 2010-06-09 for Change Record CFW003&004&005&006
        if ( !m_bSendMultiMsg )
        {
            if ( IsConnected())
            {
                ::MQCloseQueue( m_hSendQueue );
                m_hSendQueue = NULL;
                m_bstrSendQ = MPLUSCFW_EMPTY_STRING;
                m_bstrTargetHostName = MPLUSCFW_EMPTY_STRING;
                return S_OK;
            }
            return ERROR_CFW_FAILED_NOT_CONNECTED;
        }
        else
        {
            // sunyongjie add start on 20101101
            if ( 0 == m_validQueueArr.size() )
            {
                return ERROR_CFW_FAILED_NOT_CONNECTED;
            }
            // sunyongjie add end on 20101101
            for( UINT i = 0; i < m_validQueueArr.size(); i++ )
            {
                if ( IsConnected( m_validQueueArr[i].hQueueHandle ))
                {
                    ::MQCloseQueue( m_validQueueArr[i].hQueueHandle );
                    m_validQueueArr[i].hQueueHandle=NULL;
                    m_validQueueArr[i].bstrQueueName = MPLUSCFW_EMPTY_STRING;
                }
                else
                {
                    return ERROR_CFW_FAILED_NOT_CONNECTED;
                }
            }  
            m_validQueueArr.clear();
            m_bstrTargetHostName = MPLUSCFW_EMPTY_STRING;

            return S_OK;
        }
        // yutianyi modify end on 2010-06-09 for Change Record CFW003&004&005&006
    }
    catch( ... )
    {
        // WeiXueyuan add start on 2009-1-5
        // ProjectID: TMS604
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        ErrorDetail stErrorDetail;
        CString cTemp = _T("DisConnect");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, 
            stErrorDetail );
        // weixueyuan add end on 2009-1-5
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
// yangke delete start on 20101025 for directory structure change
/**
 * Build a private queue
 * @param     bstrName: queue name
 * @return    _bstr_t: normative queue name
 * @since     1.00
*/
/*
_bstr_t InnerConnector::BuildPrivateQueueName( const _bstr_t& bstrName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::BuildPrivateQueueName") );
    _bstr_t strQueue =
        _bstr_t( static_cast<LPCTSTR>(::MPLUS::FW::COMM::GetMyComputerName()));
    strQueue += MPLUSCFW_C_STRING_PRIVATE;
    strQueue += bstrName;
    return strQueue;
}

/**
 * Check whether the name of queue is valid name
 * @param     bstrName: name of target queue
 * @return    bool: Is the queue name valid.
 * @since     1.00
*/
/*
bool InnerConnector::IsValidQueueName( const _bstr_t& bstrName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::IsValidQueueName") );
    try
    {
        // Validate the parameter.
        if (( MPLUSCFW_EMPTYSTRING_LEN == bstrName.length()) ||
            ( MQ_MAX_Q_NAME_LEN < bstrName.length()))
        {
            // If invalid message, return false
            return false;
        }
        else
        {
            // Test if there's any spaces.
            CString strTrim = CString(static_cast<LPWSTR>(bstrName));
            // Eliminate space character 
            strTrim.TrimLeft();
            strTrim.TrimRight();
            // Check length of string
            if ( MPLUSCFW_CONST_ZERO == strTrim.GetLength())
            {
                // If it's 0, return false
                return false;
            }
            else
            {
                // Else return true
                return true;
            }

        }
    }
    // If method throws exception, catch it
    catch ( ... )
    {
        return false;
    }
}
*/
// yangke delete end on 20101025 for directory change

/**
 * Listen a channel and begin a thread to receive message
 * @param     bstrName:name of target queue of listening
 * @param     pFunc: callback pointer
 * @param     pParam:void pointer
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::Listen( const _bstr_t& bstrName,
                               MPLUS_MESSAGE_CALLBACK pFunc,
                               LPVOID pParam )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::Listen") );
    //TraceOutPut( _T("Start InnerConnector::Listen()") );
    try
    {
        // Validate queue name
        if ( MPLUSCFW_CONST_ZERO == bstrName.length())
        {
            // Listen to a empty channel name means unlisten!
            // Not null means listening now
            if ( NULL != m_hRecvQueue )
            {
                // If we are listening now, unlisten the channel
                // WeiXueyuan modify start on 2008-12-15
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info                
                HRESULT hRes = UnListen();
                if (FAILED(hRes))
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Listen");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
                }
                return hRes;
                // weixueyuan modify end on 2008-12-15
            }
            else
            {
                // WeiXueyuan add start on 2008-12-4
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Listen");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_NOT_CONNECTED, stErrorDetail );
                // weixueyuan add end on 2008-12-4
                // If not listening, return failed
                return ERROR_CFW_FAILED_NOT_CONNECTED;
            }
        }

        // Parameter check
        if ( NULL == pFunc )
        {
            // WeiXueyuan modify start on 2009-1-4
            // ProjectID: TMS604
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            CString cTemp = _T("Listen");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, stErrorDetail );
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        // yutianyi add start on 2010-06-25 for Change Record CFW003&004&005&006
        _bstr_t  bstrFullName;
        DWORD dwCurrentSessionID;
        ::ProcessIdToSessionId(::GetCurrentProcessId(), &dwCurrentSessionID);
        CString csSessionId( MPLUSCFW_EMPTY_STRING );
        csSessionId.Format( _T("%d"), dwCurrentSessionID );
        _bstr_t strSessionId( csSessionId );
        bstrFullName = bstrName + MPLUSCFW_CONNCT_CHARACTER + strSessionId;
        // yutianyi add end on 2010-06-25 for Change Record CFW003&004&005&006

        // The channel name must be validated
        if ( !IsValidQueueName( bstrFullName ))
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("Listen");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, stErrorDetail );
            // weixueyuan modify end on 2009-1-4
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        // We must unlisten first if we are listening
        if ( NULL != m_hRecvQueue )
        {
            // If we are listening now, unlisten the channel
            // WeiXueyuan modify start on 2008-12-15
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info                
            HRESULT hRes = UnListen();
            if (FAILED(hRes))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Listen");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
            }
            // weixueyuan modify end on 2008-12-15
        }

        DWORD dwAccess = MPLUSCFW_CONST_ZERO;

        // Initialize the receive access
        dwAccess = static_cast<DWORD>(MQ_RECEIVE_ACCESS | MQ_ADMIN_ACCESS);
        // Open the queue first
        HRESULT hr = OpenQueue( bstrFullName, m_hRecvQueue, dwAccess, false );
        if ( FAILED( hr ))
        {
            // WeiXueyuan add start on 2008-12-12
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            CString cTemp = _T("Listen");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( hr, stErrorDetail );
            // weixueyuan add end on 2008-12-12
            return hr;
        }

        // Purge the queue if we own it
        ClearQueue( m_hRecvQueue );
          
        // Prepare thread parameters
        ResetEvent( m_hExitEvent );

        m_pCallBack = pFunc;
        m_pCustom = pParam;
        m_bstrRecvQ = bstrFullName;
        if ( NULL != m_pCallBack )
        {
            //TraceOutPut( _T("Before ::AfxBeginThread()") );
            // Start the watch thread
            m_pThread = ::AfxBeginThread( WatchThread, this );
            if ( NULL == m_pThread )
            {
                // WeiXueyuan add start on 2008-12-4
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Listen");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_LISTEN, stErrorDetail );
                // weixueyuan add end on 2008-12-4

                // WeiXueyuan modify start on 2008-12-15
                // ProjectID: TMS585
                // BugSource: RC
                // BugID:  RC
                // BugReason: Make CFW event log more clear
                // FixSolution: add more event log info                
                HRESULT hRes = UnListen();
                if (FAILED(hRes))
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("Listen");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
                }
                // weixueyuan modify end on 2008-12-15
                return ERROR_CFW_FAILED_LISTEN;
            }            
        }
    }
    catch ( ... )
    {       
        if ( NULL != m_hRecvQueue )
        {
            // WeiXueyuan add start on 2008-12-12
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            HRESULT hRes = CloseQueue( m_hRecvQueue );
            if (FAILED(hRes))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Listen");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
            }
            m_hRecvQueue = NULL;
        }
        ErrorDetail stErrorDetail;
        CString cTemp = _T("Listen");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // weixueyuan add end on 2008-12-12
        return ERROR_CFW_FAILED_OPEN;
    }

    //TraceOutPut( _T("End InnerConnector::Listen()") );

    return S_OK;
}
// yutianyi add start on 2010-09-15 for Change Record CFW005
/**
 * ListenForTempQueue
 * @param     bstrName: temp queue name
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::ListenForTempQueue( const _bstr_t& bstrName)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ListenForTempQueue") );
    //TraceOutPut( _T("Start InnerConnector::Listen()") );
    try
    {
        // Validate queue name
        if ( MPLUSCFW_CONST_ZERO == bstrName.length())
        {
            // Listen to a empty channel name means unlisten!
            // Not null means listening now
            if ( NULL != m_hRecvQueue )
            {
                // If we are listening now, unlisten the channel            
                HRESULT hRes = UnListen();
                if (FAILED(hRes))
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("ListenForTempQueue");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
                }
                return hRes;
            }
            else
            {

                ErrorDetail stErrorDetail;
                CString cTemp = _T("ListenForTempQueue");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_NOT_CONNECTED, stErrorDetail );
                // If not listening, return failed
                return ERROR_CFW_FAILED_NOT_CONNECTED;
            }
        }


        // yutianyi add start on 2010-06-25 for Change Record CFW003&004&005&006
        _bstr_t  bstrFullName;
        DWORD dwCurrentSessionID;
        ::ProcessIdToSessionId(::GetCurrentProcessId(), &dwCurrentSessionID);
        CString csSessionId( MPLUSCFW_EMPTY_STRING );
        csSessionId.Format( _T("%d"), dwCurrentSessionID );
        _bstr_t strSessionId( csSessionId );
        bstrFullName = bstrName + MPLUSCFW_CONNCT_CHARACTER + strSessionId;
        // yutianyi add end on 2010-06-25 for Change Record CFW003&004&005&006

        // The channel name must be validated
        if ( !IsValidQueueName( bstrFullName ))
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("ListenForTempQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, stErrorDetail );
            // weixueyuan modify end on 2009-1-4
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        // We must unlisten first if we are listening
        if ( NULL != m_hRecvQueue )
        {
            // If we are listening now, unlisten the channel              
            HRESULT hRes = UnListen();
            if (FAILED(hRes))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("ListenForTempQueue");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
            }
        }

        DWORD dwAccess = MPLUSCFW_CONST_ZERO;

        // Initialize the receive access
        dwAccess = static_cast<DWORD>(MQ_RECEIVE_ACCESS | MQ_ADMIN_ACCESS);
        // Open the queue first
        HRESULT hr = OpenQueue( bstrFullName, m_hRecvQueue, dwAccess, false );
        if ( FAILED( hr ))
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("ListenForTempQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( hr, stErrorDetail );
            return hr;
        }

        // Purge the queue if we own it
        ClearQueue( m_hRecvQueue );

        // Prepare thread parameters
        ResetEvent( m_hExitEvent );

        m_bstrRecvQ = bstrFullName;

        //TraceOutPut( _T("Before ::AfxBeginThread()") );
        // Start the watch thread
        m_pThread = ::AfxBeginThread( WatchThread, this );
        if ( NULL == m_pThread )
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("ListenForTempQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_LISTEN, stErrorDetail );          
            HRESULT hRes = UnListen();
            if (FAILED(hRes))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("ListenForTempQueue");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrFullName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
            }
            return ERROR_CFW_FAILED_LISTEN;
        }            
    }
    catch ( ... )
    {       
        if ( NULL != m_hRecvQueue )
        {
            HRESULT hRes = CloseQueue( m_hRecvQueue );
            if (FAILED(hRes))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("ListenForTempQueue");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( hRes, stErrorDetail );
            }
            m_hRecvQueue = NULL;
        }
        ErrorDetail stErrorDetail;
        CString cTemp = _T("ListenForTempQueue");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        return ERROR_CFW_FAILED_OPEN;
    }

    return S_OK;
}
// yutianyi add end on 2010-09-15 for Change Record CFW005
// yangke delete start on 20101025 for directory structure change 
/*
/**
 * Cancel listening
 * @param     void
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
*/
/*
HRESULT InnerConnector::UnListen()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::UnListen") );
    try
    {
        // If we are listening
        if ( !IsListening())
        {
            return S_OK;
        }

        // Stop the thread.
        if ( NULL != m_pThread )
        {
            // We are calling this function in normal thread
            if ( ::GetCurrentThreadId() != m_pThread->m_nThreadID )
            {
                // Generate signal to thread to abort it
                SetEvent( m_hExitEvent );
                DWORD dwResult = WAIT_TIMEOUT;
                while ( WAIT_TIMEOUT == dwResult )
                {
                    // Wait thread abort
                    ::Sleep( MPLUSCFW_CONST_ZERO );
                    dwResult = ::WaitForSingleObject( m_pThread->m_hThread,
                        MPLUSCFW_UNLISTEN_WAIT_TIME );
                }
                m_pThread = NULL;
            }
            // If current thread is worker thread, it's wrong state
            else
            {
                CFW_OUTPUT_ERROR( ERROR_CFW_WRONG_STATE );                
                return ERROR_CFW_WRONG_STATE;
            }
        }      

        // Close the queue
        if ( NULL != m_hRecvQueue )
        {
            // WeiXueyuan modify end on 2009-1-4
            // ProjectID: TMS604
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            HRESULT hr = CloseQueue( m_hRecvQueue );
            if (FAILED(hr))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Unlisten");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_DELETE_QUEUE, stErrorDetail );
            }
            // WeiXueyuan modify end on 2009-1-4
            m_hRecvQueue = NULL;
        }

        // If the queue was created by us, delete it!
        if (( m_bstrRecvQ.length() > MPLUSCFW_CONST_ZERO ))
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            HRESULT hr = DeleteQueue( m_bstrRecvQ );
            if (FAILED(hr))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("Unlisten");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_DELETE_QUEUE, stErrorDetail );
            }
            // weixueyuan add end on 2008-12-4
        }

        // Reset member variables
        ResetEvent( m_hExitEvent );

        m_pCallBack = NULL;
        m_pCustom = NULL;
        m_bstrRecvQ = MPLUSCFW_EMPTY_STRING;
        return S_OK;
    }
    // If method throws exception. catch it
    catch ( ... )
    {
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
*/
/*
/**
 * Check whether message is valid
 * @param     pMsg: message that need be checked
 * @return    bool: Is the message valid.
 * @since     1.00
*//* 
bool InnerConnector::IsValidSendMessage( const IMplusMessage *pMsg )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::IsValidSendMessage") );
    try
    {
        if ( NULL == pMsg )
        {
            return false;
        }
        if ( pMsg->GetCommand().length() == MPLUSCFW_CONST_ZERO )
        {
            return false;
        }
    }
    catch ( ... )
    {
        return false;
    }
    return true;
}
*/
// yangke delete end on 20101025 for directory structure change 

/**
 * Send message, whether the message is synchronous or asynchronous
 * @param     messageIn: message that is waiting for sending
 * @param     dwCallType: mode of sending
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::SendCommon( IMplusMessage* pMsgIn,
                                    const DWORD dwCallType )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendCommon") );
    try
    {
        //TraceOutPut( _T("Start: InnerConnector::SendCommon()") );
        // Make sure we have connect to the channel
        if ( !IsConnected())
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T("SendASync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH -InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgIn->GetCommand(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = pMsgIn->GetUID();
            stErrorDetail.uReUID = pMsgIn->GetReUID();
            stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_NOT_CONNECTED, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-4
            return ERROR_CFW_FAILED_NOT_CONNECTED;
        }

        // Validate parameter
        if ( NULL == pMsgIn )
        {
            // WeiXueyuan add start on 2008-12-15
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T("SendASync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-15
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        // Validate the message
        if ( !IsValidSendMessage( pMsgIn ))
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T("SendASync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = pMsgIn->GetUID();
            stErrorDetail.uReUID = pMsgIn->GetReUID();
            stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_COMMAND_IS_EMPTY, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-4
            return ERROR_CFW_COMMAND_IS_EMPTY;
        }

        // Validate message address
        if ( !IsValidQueueName( pMsgIn->GetFromAddress()))
        {
            pMsgIn->SetFromAddress( m_bstrRecvQ );
        }
        if ( !IsValidQueueName( pMsgIn->GetToAddress()))
        {
            pMsgIn->SetToAddress( m_bstrSendQ );
        }

        // Set message priority
        pMsgIn->SetCallType( dwCallType );

        DWORD dwTick = GetTickCount();
        WCHAR strTick[MPLUSCFW_WCHARARRAY_SIZE] = MPLUSCFW_EMPTY_STRING;
        
        // Prepare message property
        swprintf( strTick, _T( "%u" ), dwTick );
        pMsgIn->SetTimeStamp( _bstr_t( strTick ));

        // If timeout is not set, set infinite
        if ( MPLUSCFW_TIMEOUT_NOWAIT == pMsgIn->GetTimeOut())
        {
            pMsgIn->SetTimeOut( static_cast<DWORD>(INFINITE));
        }

        // Set UID for message
        UINT64 unMsgUID = ::MPLUS::FW::COMM::GetMessageUID();
        pMsgIn->SetUID( unMsgUID );

        // yutianyi add start on 2010-6-17 for Change Record CFW005
        // Set computer name for message
        pMsgIn->SetHostName( m_bstrMyHostName );
        // yutianyi add end on 2010-06-17 for Change Record CFW005

        // Encode message
        _bstr_t bstrMsg = SerializeMsg( pMsgIn );

        // Bad message format
        if ( MPLUSCFW_EMPTYSTRING_LEN == bstrMsg.length())
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T("SendASync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_BAD_MESG_FORMAT, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-4
            return ERROR_CFW_BAD_MESG_FORMAT;
        }
        int nPriorty = ( CFW_CALLTYPE_ASYNC == dwCallType ) ?
                              MPLUSCFW_PRIORITY_ASYNC : MPLUSCFW_PRIORITY_SYNC;

        // XueKang add start on 2009-06-12
        // ProjectID:TMS604
        // BugSource: Fix the bug send sync message fail
        // BugID: MVC002702
        // BugReson: the position for initialize m_uUidForSyncMessage should be here
        if ( CFW_CALLTYPE_SYNC == pMsgIn->GetCallType())
        {
            m_uUidForSyncMessage =  pMsgIn->GetUID();
        }        
        // XueKang add start end 2009-06-12

        // Send message
        // yutianyi modify start on 2010-07-15 for Change Record CFW005
        /*HRESULT hr = SendMsg( m_hSendQueue,
            FormatVersion( MPLUSCFW_COMM_VERSION ),
            bstrMsg, nPriorty, pMsgIn->GetTimeOut());*/
        //yangke 20100817 start
        _bstr_t bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
        if(MPLUSCFW_CONST_ZERO == m_bstrRecvQ.length() && 
            pMsgIn->GetFromAddress().length() == MPLUSCFW_CONST_ZERO)
        {
            bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
        }
        else
        {
            bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            CString csFormatName = MPLUSCFW_EMPTY_STRING;
            if(pMsgIn->GetFromAddress().length() != MPLUSCFW_CONST_ZERO)
            {
                if(pMsgIn->GetSessionId().length()!=MPLUSCFW_CONST_ZERO)
                {   
                    CString csFullQueueName = MPLUSCFW_EMPTY_STRING;
                    csFullQueueName.Format(_T("%s_%s"),(LPTSTR)pMsgIn->GetFromAddress()
                    ,(LPTSTR)pMsgIn->GetSessionId());
                        csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                        (LPTSTR)m_bstrMyHostName, csFullQueueName);
                }
                else
                {
                    csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                        (LPTSTR)m_bstrMyHostName, (LPTSTR)pMsgIn->GetFromAddress());
                }
                
            }
            else
            {
                csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                    (LPTSTR)m_bstrMyHostName, (LPTSTR)m_bstrRecvQ );
            }

            bstrFormatName = _bstr_t(static_cast<LPCWSTR>(csFormatName));
        }
        //yangke 20100817 end
        HRESULT hr = SendMsg( m_hSendQueue,
            FormatVersion( MPLUSCFW_COMM_VERSION ),
            bstrMsg, nPriorty, pMsgIn->GetTimeOut(), bstrFormatName ); 
        // yutianyi modify end on 2010-07-15 for Change Record CFW005
        if ( FAILED( hr ))
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T( "SendSync" );
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T( "SendASync" );
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgIn->GetCommand(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = pMsgIn->GetUID();
            stErrorDetail.uReUID = pMsgIn->GetReUID();
            stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_SEND, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-4
        }

        //TraceOutPut( _T("End: InnerConnector::SendCommon()") );

        return hr;
    }
    catch (...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        ErrorDetail stErrorDetail;
        if ( dwCallType == CFW_CALLTYPE_SYNC )
        {
            CString cTemp = _T("SendSync");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        }
        else if ( dwCallType == CFW_CALLTYPE_ASYNC )
        {
            CString cTemp = _T("SendASync");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        }
        CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgIn->GetCommand(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
        stErrorDetail.uUID = pMsgIn->GetUID();
        stErrorDetail.uReUID = pMsgIn->GetReUID();
        stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, 
            stErrorDetail );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}

/**
 * Send asynchronous message
 * @param     pMsgIn: message that is waiting for sending
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::SendASync( IMplusMessage* pMsgIn )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendASync") );
    // Validate parameters
    //TraceOutPut( _T("Start InnerConnector::SendASync()") );
    
    if ( NULL == pMsgIn )
    {
        // WeiXueyuan add start on 2008-12-15
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        ErrorDetail stErrorDetail;
        CString cTemp = _T("SendASync");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
            stErrorDetail );
        // weixueyuan add end on 2008-12-15
        return ERROR_CFW_INVALID_PARAMETERS;
    }
// [TMS342] Performance [2007-7-30] (TCH)zhaidazhong modified start: comment out, no need lock/unlock for sending
//    m_RecvLock.Lock();
    // yutianyi modify start on 2010-06-09 for Change Record CFW003&004&005&006
    //HRESULT hr = SendCommon( pMsgIn, CFW_CALLTYPE_ASYNC );
    HRESULT hr = S_OK;
    if ( m_bSendMultiMsg )
    {
        hr = SendMultiCommon( pMsgIn, CFW_CALLTYPE_ASYNC );
    }
    else
    {
        hr = SendCommon( pMsgIn, CFW_CALLTYPE_ASYNC );
    }
    // yutianyi modify end on 2010-06-09 for Change Record CFW003&004&005&006
//    m_RecvLock.Unlock();
// [TMS342] Performance [2007-7-30] (TCH)zhaidazhong modified end: comment out, no need lock/unlock for sending
    
    //TraceOutPut( _T("End InnerConnector::SendASync()") );
    
    return hr;
}

// yangke delete start on 20101025 for directory structure change
/**
 * Check handle whether is correct
 * @param     hQueue: handle that will be checked
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
*/
/*
HRESULT InnerConnector::CheckHandle( const QUEUEHANDLE& hQueue )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CheckHandle") );
    try
    {
        //TraceOutPut( _T("Start InnerConnector::CheckHandle()") );
        // Null is not valid handle
        if ( NULL == hQueue )
        {
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        TCHAR szFormatName[MPLUSCFW_MAX_FORMAT_NAME_LEN] =
            MPLUSCFW_EMPTY_STRING;
        DWORD dwSize = MPLUSCFW_MAX_FORMAT_NAME_LEN;
        // Get the queue name from handle
        //TraceOutPut( _T("Before ::MQHandleToFormatName()") );
        HRESULT hr = ::MQHandleToFormatName(
            hQueue,
            static_cast<LPWSTR>(szFormatName),
            &dwSize );
        //TraceOutPut( _T("After ::MQHandleToFormatName()") );
        hr = MQErrToLocal( hr );
        if ( FAILED( hr ))
        {
            return hr;
        }
        DWORD cPropId = MPLUSCFW_ARRAY_CONUT_ZERO;

        // Define a queue property structure.
        MQQUEUEPROPS   aQueueProps;
        ::ZeroMemory( &aQueueProps, sizeof(aQueueProps));
        QUEUEPROPID    aQueuePropId[MPLUSCFW_MSGPROPID_SIZE_ONE];
        ::ZeroMemory( aQueuePropId, sizeof(aQueuePropId));
        MQPROPVARIANT  aQueuePropVar[MPLUSCFW_MQPROPVARIANT_SIZE_ONE];
        ::ZeroMemory( aQueuePropVar, sizeof(aQueuePropVar));
        HRESULT        aQueuePropStatus[MPLUSCFW_HRESULT_SIZE_ONE];
        aQueuePropStatus[MPLUSCFW_CONST_ZERO] = E_FAIL;

        // Specify the PROPID_Q_LABEL property.
        aQueuePropId[cPropId] = PROPID_Q_LABEL;       // Property ID
        aQueuePropVar[cPropId].vt = VT_NULL;          // Type indicator
        cPropId++;

        // Initialize the MQQUEUEPROPS structure.
        aQueueProps.cProp = cPropId;
        aQueueProps.aPropID = static_cast<QUEUEPROPID*>(aQueuePropId);
        aQueueProps.aPropVar = static_cast<MQPROPVARIANT*>(aQueuePropVar);
        aQueueProps.aStatus = static_cast<HRESULT*>(aQueuePropStatus);


        // Validate the input string.
        if ( NULL == szFormatName )
        {
            return ERROR_CFW_INVALID_PARAMETERS;
        }


        // Get the queue properties.
        //TraceOutPut( _T("Before ::MQGetQueueProperties()") );
        hr = ::MQGetQueueProperties( static_cast<LPCWSTR>(szFormatName),
            &aQueueProps );
        ::MQFreeMemory( aQueuePropVar[MPLUSCFW_CONST_ZERO].pwszVal );
        //TraceOutPut( _T("After ::MQGetQueueProperties()") );

        //TraceOutPut( _T("End InnerConnector::CheckHandle()") );

        return MQErrToLocal( hr );
    }
    catch (...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        CFW_OUTPUT_ERROR( ERROR_CFW_UNKNOWN_ERROR );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}

/**
 * Check whether it has listened
 * @param     void
 * @return    bool: Is the connector listening.
 * @since     1.00
*/
/*
bool InnerConnector::IsListening()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::IsListening") );
    if ( SUCCEEDED( CheckHandle( m_hRecvQueue )))
    {
        return true;
    }
    return false;
}
*/
// yangke delete end on 20101025 for directory structure change

// yutianyi modify start on 2010-06-09 for Change Record CFW003&004&005&006
//bool InnerConnector::IsConnected()
/**
 * Check whether it has valid connection
 * @param     void
 * @return    bool: Is the connector connected with a valid send handle.
 * @since     1.00
*/
bool InnerConnector::IsConnected( QUEUEHANDLE hSendHandle /*=NULL */)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::IsConnected") );
    /*if ( SUCCEEDED( CheckHandle( m_hSendQueue )))
    {
        return true;
    }
    return false;*/
    // The checkhandle interface is not work for across host queue
    CString csHostName = (LPCTSTR)m_bstrTargetHostName;
    CString csMyHostName = (LPCTSTR)m_bstrMyHostName;
    // yangke modified start on 2010-10-30 for AT bug
    if(csMyHostName.CompareNoCase(csHostName)!=0 &&
        csHostName.CompareNoCase(MPLUSCFW_EMPTY_STRING)!=0 )
    {
        return true;
    }
    // yangke modified end on 2010-10-30 for AT bug

    if ( NULL == hSendHandle )
    {
        if ( SUCCEEDED( CheckHandle( m_hSendQueue )))
        {
            return true;
        }
    }
    else
    {
        if ( SUCCEEDED( CheckHandle( hSendHandle )))
        {
            return true;
        }
    }
    
    return false;
}
// yutianyi modify end on 2010-06-09 for Change Record CFW003&004&005&006
/*
// yangke delete start on 20101025 for directory structure change
/**
 * Send message by MQ, so it is actual function of sending
 * @param     hQueue: handle of target queue
 * @param     bstrLabel: label of target queue
 * @param     bstrMsg: message that is waiting for sending
 * @param     nPriorty: priority of sending
 * @param     dwTimeout: wait time
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
*/ 
// yutianyi modify start on 2010-07-14 for Change Record CFW005
/*HRESULT InnerConnector::SendMsg( const QUEUEHANDLE& hQueue,
                                 const _bstr_t& bstrLabel,
                                 const _bstr_t& bstrMsg,
                                 int nPriorty,
                                 DWORD dwTimeout )
HRESULT InnerConnector::SendMsg( const QUEUEHANDLE& hQueue,
                                 const _bstr_t& bstrLabel,
                                 const _bstr_t& bstrMsg,
                                 int nPriorty,
                                 DWORD dwTimeout,
                                 const _bstr_t& bstrFormatName )
// yutianyi modify start on 2010-07-14 for Change Record CFW005
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendMsg") );
    //TraceOutPut( _T("Start: InnerConnector::SendMsg()") );
    try
    {
// [TMS342] Performance [2007-7-30] (TCH)zhaidazhong modified start: comment out, no need check each time
        HRESULT hr = S_OK;
/*        HRESULT hr = CheckHandle( hQueue );
        if ( S_OK != hr )
        {
            return hr;
        }
*/
/*        
// [TMS342] Performance [2007-7-30] (TCH)zhaidazhong modified end: comment out, no need check each time

        // Initialize the properties.
        DWORD cProps = MPLUSCFW_ARRAY_CONUT_ZERO;
        MQMSGPROPS    propsMessage;
        ::ZeroMemory( &propsMessage, sizeof(propsMessage) );
        // yutianyi modify start on 2010-07-14 for Change Record CFW005
        /*MQPROPVARIANT aPropVar[MPLUSCFW_MQPROPVARIANT_SIZE_SIX];
        ::ZeroMemory( aPropVar, sizeof(aPropVar) );
        MSGPROPID     aPropId[MPLUSCFW_MSGPROPID_SIZE_SIX];
        ::ZeroMemory( aPropId, sizeof(aPropId) );*/

/*
        MQPROPVARIANT aPropVar[MPLUSCFW_MQPROPVARIANT_SIZE_SEVEN];
        ::ZeroMemory( aPropVar, sizeof(aPropVar) );
        MSGPROPID     aPropId[MPLUSCFW_MSGPROPID_SIZE_SEVEN];
        ::ZeroMemory( aPropId, sizeof(aPropId) );
        // yutianyi modify end on 2010-07-14 for Change Record CFW005

        // Set message priority
        if (( nPriorty < MPLUSCFW_LOWEST_PRIORITY ) ||
            ( nPriorty > MPLUSCFW_HIGHEST_PRIORITY ))
        {
            nPriorty = MPLUSCFW_PRIORITY_ASYNC;
        }
        // 0
        aPropId[cProps] = PROPID_M_BODY;
        aPropVar[cProps].vt = VT_UI1 | VT_VECTOR;
        aPropVar[cProps].caub.cElems = bstrMsg.length() * sizeof(WCHAR);
        aPropVar[cProps].caub.pElems =
            reinterpret_cast<UCHAR*>(bstrMsg.operator wchar_t*());
        cProps++;
        
        // WeiXueyuan add start on 2009-1-7
        // ProjectID: TMS604
        // BugSource: Result of Microsoft Application Verifier.
        // BugID: Result of Microsoft Application Verifier.
        // BugReason: Convert from const WCHAR* to WCHAR*
        // FixSolution: Don not use conversion
        TCHAR szName[_MAX_PATH] = MPLUSCFW_EMPTY_STRING;
        _tcsncpy( szName, static_cast<LPCTSTR>(bstrLabel), ::SysStringLen(bstrLabel) );

        // 1
        aPropId[cProps] = PROPID_M_LABEL;
        aPropVar[cProps].vt = VT_LPWSTR;
        aPropVar[cProps].pwszVal = szName;
        // weixueyuan add end on 2009-1-7
        cProps++;
        // 2
        aPropId[cProps] = PROPID_M_DELIVERY;
        aPropVar[cProps].vt = VT_UI1;
        aPropVar[cProps].bVal = MQMSG_DELIVERY_EXPRESS;
        cProps++;
        // 3    
        aPropId[cProps] = PROPID_M_PRIORITY;
        aPropVar[cProps].vt = VT_UI1;
        aPropVar[cProps].bVal = static_cast<UCHAR>(nPriorty);
        cProps++;
        // 4
        aPropId[cProps] = PROPID_M_BODY_TYPE;
        aPropVar[cProps].vt = VT_UI4;
        aPropVar[cProps].ulVal = static_cast<ULONG>(VT_BSTR);
        cProps++;
        // 5
        aPropId[cProps] = PROPID_M_TIME_TO_BE_RECEIVED;
        aPropVar[cProps].vt = VT_UI4;
        aPropVar[cProps].ulVal = static_cast<ULONG>(dwTimeout);
        cProps++;
        // yutianyi add start on 2010-07-14 for Change Record CFW005
        // 6
        //yangke 20100817 start
        if(MPLUSCFW_CONST_ZERO != bstrFormatName.length())
        {
            TCHAR szFormatName[_MAX_PATH] = MPLUSCFW_EMPTY_STRING;
            _tcsncpy( szFormatName, static_cast<LPCTSTR>(bstrFormatName), 
                ::SysStringLen(bstrFormatName) );
            aPropId[cProps] = PROPID_M_RESP_FORMAT_NAME;
            aPropVar[cProps].vt = VT_LPWSTR;
            aPropVar[cProps].pwszVal = szFormatName;
            cProps++;
        }
        //yangke 20100817 end
        // yutianyi add end on 2010-07-14 for Change Record CFW005
        // Set property of MQ
        propsMessage.cProp = cProps;
        propsMessage.aPropID = static_cast<MSGPROPID*>(aPropId);
        propsMessage.aPropVar = static_cast<MQPROPVARIANT*>(aPropVar);
        propsMessage.aStatus = NULL;

        // Send message.

        //TraceOutPut( _T("Before: ::MQSendMessage()") );
        hr = ::MQSendMessage( hQueue,
            &propsMessage,
            static_cast<ITransaction *>(NULL));
        MPlusMessage msgRet;
        InnerConnector::DeserializeMsg( bstrMsg, &msgRet ); 
        UINT64 uReUid = msgRet.GetReUID();
        DWORD dwCallType = msgRet.GetCallType();
        TCHAR output[OUTPUTMAXLEN];
        if ( SUCCEEDED( hr ))
        {
            // [XueKang] [add] start on 2009-01-13
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW trace log more clear
            // FixSolution: add more trace log info  for sending/receiving message
            if (( dwCallType == CFW_CALLTYPE_SYNC ) &&
                ( uReUid == 0 ))
            {
                _sntprintf( output, OUTPUTMAXLEN, _T( "[SendSync] SenderName:%s, SenderQName:%s \
                ReceiverQName:%s Command:%s\n \
                Parameter:%s, Custom:%s\n \
                UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
                ( LPCTSTR )msgRet.GetSender(), ( LPCTSTR )msgRet.GetFromAddress(), 
                ( LPCTSTR )msgRet.GetToAddress(), ( LPCTSTR )msgRet.GetCommand(),
                ( LPCTSTR )msgRet.GetParameter(), ( LPCTSTR )msgRet.GetCustom(),
                msgRet.GetUID(), msgRet.GetReUID(),msgRet.GetTimeOut());
                MPLUS_TRACE_P2P_SEND( output );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                _sntprintf( output, OUTPUTMAXLEN, _T( "[SendASync] SenderName:%s, SenderQName:%s \
                ReceiverQName:%s Command:%s\n \
                Parameter:%s, Custom:%s\n \
                UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
                ( LPCTSTR )msgRet.GetSender(), ( LPCTSTR )msgRet.GetFromAddress(), 
                ( LPCTSTR )msgRet.GetToAddress(), ( LPCTSTR )msgRet.GetCommand(),
                ( LPCTSTR )msgRet.GetParameter(), ( LPCTSTR )msgRet.GetCustom(),
                msgRet.GetUID(), msgRet.GetReUID(),msgRet.GetTimeOut());
                MPLUS_TRACE_P2P_SEND( output );
             }
            // [XueKang] [add] end on 2009-01-13
            
        }
        //TraceOutPut( _T("After: ::MQSendMessage()") );
        hr = MQErrToLocal( hr );

        //TraceOutPut( _T("End: InnerConnector::SendMsg()") );
        return hr;
    }
    catch(...)
    {
        return ERROR_CFW_FAILED_SEND;
    }
}
*/
/*
/**
 * Send message only once.
 * @param     bstrName: name of target queue
 * @param     bstrLabel: label of target queue
 * @param     bstrMsg: message that waiting for sending
 * @param     nPriorty: Priority of sending
 * @param     dwTimeout: wait time
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 
// yutianyi modify start on 2010-06-22 for Change Record CFW005
/*HRESULT InnerConnector::SendOnce( const _bstr_t& bstrName,
                                 const DWORD dwVersion,
                                 const _bstr_t& bstrMsg,
                                 int nPriorty,
                                 DWORD dwTimeout )
*/
/*
HRESULT InnerConnector::SendOnce( const _bstr_t& bstrName,
                                 const DWORD dwVersion,
                                 const _bstr_t& bstrMsg,
                                 int nPriorty,
                                 DWORD dwTimeout,
                                 const _bstr_t& bstrFormatName,
                                 const _bstr_t& bstrHostName )
// yutianyi modify end on 2010-06-22 for Change Record CFW005
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendOnce") );
    try
    {
        // Validate the parameters.
        if ( !IsValidQueueName( bstrName ))
        {
            // WeiXueyuan add start on 2008-12-17
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            MPlusMessage msgRet;
            InnerConnector::DeserializeMsg( bstrMsg, &msgRet );        
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendReply");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)msgRet.GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)msgRet.GetFromAddress(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)msgRet.GetCommand(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)msgRet.GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)msgRet.GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = msgRet.GetUID();
            stErrorDetail.uReUID = msgRet.GetReUID();
            stErrorDetail.dTimeOut = msgRet.GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-17
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        // Open the queue first.
        QUEUEHANDLE hQueue = NULL;
        // yutianyi modify start on 2010-06-22 for Change Record CFW005
        //HRESULT hr = OpenQueue( bstrName, hQueue, MQ_SEND_ACCESS, true );
        HRESULT hr = OpenQueue( bstrName, hQueue, MQ_SEND_ACCESS, true, bstrHostName );
        // yutianyi modify end on 2010-06-22 for Change Record CFW005
        if ( S_OK != hr )
        {
            // WeiXueyuan add start on 2008-12-12
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            MPlusMessage msgRet;
            InnerConnector::DeserializeMsg( bstrMsg, &msgRet );        
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendReply");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)msgRet.GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)msgRet.GetFromAddress(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)msgRet.GetCommand(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)msgRet.GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)msgRet.GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = msgRet.GetUID();
            stErrorDetail.uReUID = msgRet.GetReUID();
            stErrorDetail.dTimeOut = msgRet.GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_OPEN, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-12
            return ERROR_CFW_FAILED_OPEN;
        }
        // [XueKang] [add] start on 2008-11-25
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW trace log more clear   
        TCHAR output[OUTPUTMAXLEN];
        MPlusMessage msgRet;
        InnerConnector::DeserializeMsg( bstrMsg, &msgRet );
        _sntprintf( output, OUTPUTMAXLEN, _T( "[SendReply] SenderName:%s, \
            SenderQName:%s ReceiverQName:%s Command:%s\n \
            Parameter:%s, Custom:%s\n \
            UID:%I64u, ReUID:%I64u, TimeOut:%d" ), 
            ( LPCTSTR )msgRet.GetSender(), 
            ( LPCTSTR )msgRet.GetFromAddress(),
            ( LPCTSTR )msgRet.GetToAddress(),
            ( LPCTSTR )msgRet.GetCommand(),
            ( LPCTSTR )msgRet.GetParameter(),
            ( LPCTSTR )msgRet.GetCustom(),
            msgRet.GetUID(), msgRet.GetReUID(),
            msgRet.GetTimeOut()); 
        MPLUS_TRACE_P2P_SEND( output );
        // [XueKang] [add] start on 2008-11-25
        // Send message.
        _bstr_t bstrLabel = FormatVersion( dwVersion );
        // yutianyi modify start on 2010-07-15 for Change Record CFW005
        //hr = SendMsg( hQueue, bstrLabel, bstrMsg, nPriorty, dwTimeout );
        hr = SendMsg( hQueue, bstrLabel, bstrMsg, nPriorty, dwTimeout, bstrFormatName );
        // yutianyi modify end on 2010-07-15 for Change Record CFW005

        // Close the queue.
        // WeiXueyuan add start on 2008-12-12
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        HRESULT hRes = CloseQueue( hQueue );
        if (FAILED(hRes))
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendReply");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)msgRet.GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)msgRet.GetFromAddress(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)msgRet.GetCommand(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)msgRet.GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)msgRet.GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = msgRet.GetUID();
            stErrorDetail.uReUID = msgRet.GetReUID();
            stErrorDetail.dTimeOut = msgRet.GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( hRes, 
                stErrorDetail );
        }
            // weixueyuan add end on 2008-12-12
        if ( FAILED( hr ) )
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendReply");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)msgRet.GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)msgRet.GetFromAddress(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)msgRet.GetCommand(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)msgRet.GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)msgRet.GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = msgRet.GetUID();
            stErrorDetail.uReUID = msgRet.GetReUID();
            stErrorDetail.dTimeOut = msgRet.GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_SEND, 
                stErrorDetail );
            // weixueyuan add end on 2008-12-4
            return ERROR_CFW_FAILED_SEND;
        }
        return hr;
    }
    catch ( ... )
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        MPlusMessage msgRet;
        InnerConnector::DeserializeMsg( bstrMsg, &msgRet );
        ErrorDetail stErrorDetail;
        CString cTemp = _T("SendReply");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)msgRet.GetSender(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)msgRet.GetFromAddress(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)bstrName, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)msgRet.GetCommand(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)msgRet.GetParameter(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)msgRet.GetCustom(), MAX_LENGTH - InitOne );
        stErrorDetail.uUID = msgRet.GetUID();
        stErrorDetail.uReUID = msgRet.GetReUID();
        stErrorDetail.dTimeOut = msgRet.GetTimeOut();
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, 
                stErrorDetail );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
*/
/**
 * Abort SendSync operation
 * @param     void
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
*/
/*
HRESULT InnerConnector::Abort( void )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::Abort") );
    m_abortFlag.SetValue( MPLUSCFW_C_DWORD_FLAGTRUE );
    return S_OK;
}
*/
// yangke delete end on 20101025 for directory structure change

/**
 * Send synchronous message
 * @param     pMessageIn: message that is waiting for sending
 * @param     pMessageRet: pointer of receiving reply message
 * @param     dwWaitTimeOut: wait time
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::SendSync( IMplusMessage* pMessageIn,
                                 IMplusMessage* pMessageRet,
                                 DWORD dwWaitTimeOut )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendSync") );
    try
    {
        // Validate parameters
        if (( NULL == pMessageRet ) || ( NULL == pMessageIn ))
        {
            // WeiXueyuan add start on 2008-12-15
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendSync");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                stErrorDetail );
        // weixueyuan add end on 2008-12-15
            return ERROR_CFW_INVALID_PARAMETERS;
        }
        // WeiXueyuan modify start on 2009-1-7
        // ProjectID: TMS604
        // BugSource: RC
        // BugID:  RC
        // BugReason: ASync I/O
        // FixSolution: Use ASync I/O
        m_pMessageRet = pMessageRet;
        m_bSendSyncMsg = true;

        // XueKang add start on 2009-06-12
        // ProjectID:TMS604
        // BugSource: Fix the bug for dead lock
        // BugID: 
        // BugReson: the position for initialize m_hSendSyncEvent should be here
        ::ResetEvent( m_hSendSyncEvent ); 
        // XueKang add end on 2009-06-12        

        // yutianyi modify start on 2010-06-09 for Change Record CFW003&004&005&006
        HRESULT hr = S_OK;
        if ( m_bSendMultiMsg )
        {
            // we need initialize this value before send
            m_bSendSyncPartOK = false;
            hr = SendMultiCommon( pMessageIn, CFW_CALLTYPE_SYNC );
            if ( FAILED( hr ))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_SEND, 
                    stErrorDetail );
                return hr;
            }
        }
        else
        {
            hr = SendCommon( pMessageIn, CFW_CALLTYPE_SYNC );
            if ( FAILED( hr ))
            {
                m_uUidForSyncMessage = 0;
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_SEND, 
                    stErrorDetail );
                return hr;
            }
        }
        // yutianyi modify end on 2010-06-09 for Change Record CFW003&004&005&006

        HANDLE hWaitHandle[WAITOBJECTCOUNT];
        hWaitHandle[FIRSTOBJECT] = NULL;
        hWaitHandle[SECONDOBJECT] = NULL;
        
        hWaitHandle[FIRSTOBJECT] = m_hSendSyncEvent;
        if ( NULL == hWaitHandle[FIRSTOBJECT] )
        {
            return ERROR_CFW_FAILED_RECV;
        }
        // for abort send sync
        hWaitHandle[SECONDOBJECT] = m_hSendSyncAbortEvent;           
        if ( NULL == hWaitHandle[SECONDOBJECT] )
        {            
            return ERROR_CFW_FAILED_RECV;
        }
        
        DWORD dResult = ::WaitForMultipleObjects( 
            WAITOBJECTCOUNT, hWaitHandle, FALSE, dwWaitTimeOut ); 
        
        if ( WAIT_OBJECT_0 == dResult )
        {   
            //pMessageRet = m_pMessageRet;  
           
            return S_OK;
        }
        else if ( WAIT_OBJECT_0 +1 == dResult )
        {
            // Should notify other the call is aborted 
            return ERROR_CFW_USERABORT;
        }
        else if( WAIT_TIMEOUT == dResult)
        { 
            // In Multi send if any sync message is success
            // we think this send process is success, but single sync message
            // not care this verification
            CString csQueueFailList = MPLUSCFW_EMPTY_STRING;
            if(m_bSendSyncPartOK == true && m_bSendMultiMsg == true)
            {
                for( UINT i = 0; i < m_validQueueArr.size(); i++ )
                {
                    if(m_validQueueArr[i].bState == false)
                    {
                        csQueueFailList += (LPCTSTR)m_validQueueArr[i].bstrQueueName;
                        csQueueFailList +=_T(",");
                    }
                }
                m_bSendSyncPartOK = false;
                m_pMessageRet = NULL; // related with watchthread
                hr = S_OK;

                ///output warning detail info for send part OK
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)csQueueFailList, MAX_LENGTH - InitOne );
                CFW_OUTPUT_WARNING_DETAIL( ERROR_CFW_FAILED_SEND, stErrorDetail );
                return hr;
            }
            else // m_bSendMultiMsg == true and no valid return msg
            {    // or m_bSendMultMsg == false and no valid return msg
                m_pMessageRet = NULL;
                hr = ERROR_CFW_WAITTIMEOUT;
                return hr;
            }
            //hr = ERROR_CFW_WAITTIMEOUT; it also need consider
        }
        else
        {
            return ERROR_CFW_FAILED_RECV;
        }
    }
    catch(...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        ErrorDetail stErrorDetail;
        CString cTemp = _T("RecvReply");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMessageIn->GetToAddress(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMessageIn->GetFromAddress(), MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}

// yangke delete start on 20101025 for directory structure change
/**
 * Create a queue
 * @param     bstrName: name of queue that will be create
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
/*
HRESULT InnerConnector::CreateQueue( const _bstr_t& bstrName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CreateQueue") );
    try
    {
        // Build broadcast channel name
        TCHAR szFormatName[MPLUSCFW_MAX_FORMAT_NAME_LEN ] =
            MPLUSCFW_EMPTY_STRING;
        ::ZeroMemory( szFormatName, sizeof(szFormatName));
        DWORD dwNumChars = MPLUSCFW_MAX_FORMAT_NAME_LEN ;
        // Create broadcast queue
        HRESULT hr = CreateQueue( bstrName, szFormatName, &dwNumChars );

        // Check whether operation is successful
        return hr;
    }
    catch (...)
    {
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
*/
/**
 * Create a queue
 * @param     bstrName:  name of queue that will be create
 * @param     wcsFormatName: normative name of queue
 * @param     pdwNumChars:  specifies the length of the wcsFormatName buffer
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
/*
HRESULT InnerConnector::CreateQueue( const _bstr_t& bstrName,
                                    WCHAR* wcsFormatName, DWORD* pdwNumChars )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CreateQueue") );
    try
    {
        //TraceOutPut( _T("Start InnerConnector::CreateQueue()") );
        static GUID gMplusQtype = MPLUSCFW_QUEUE_GUID;

        // Initialize property of MQ
        DWORD cProps = MPLUSCFW_ARRAY_CONUT_ZERO;
        QUEUEPROPID  aPropId[MPLUSCFW_MSGPROPID_SIZE_THREE];
        ::ZeroMemory( aPropId, sizeof(aPropId));
        MQPROPVARIANT aPropVar[MPLUSCFW_MQPROPVARIANT_SIZE_THREE];
        ::ZeroMemory( aPropVar, sizeof(aPropVar));
        MQQUEUEPROPS propsQueue;
        ::ZeroMemory( &propsQueue, sizeof(propsQueue));

        // 0
        aPropId[cProps] = PROPID_Q_PATHNAME;
        aPropVar[cProps].vt = VT_LPWSTR;

        // 2006-2-15 temporary solution for bound checker
        _bstr_t bstrQueName = BuildPrivateQueueName( bstrName );

        // WeiXueyuan modify start on 2009-1-7
        // ProjectID: TMS604
        // BugSource: Result of Microsoft Application Verifier.
        // BugID: Result of Microsoft Application Verifier.
        // BugReason: Convert from const WCHAR* to WCHAR*
        // FixSolution: Don not use conversion
        TCHAR szQName[_MAX_PATH] = MPLUSCFW_EMPTY_STRING;
        _tcsncpy( szQName, static_cast<LPCTSTR>(bstrQueName), ::SysStringLen(bstrQueName) );

        TCHAR szName[_MAX_PATH] = MPLUSCFW_EMPTY_STRING;
        _tcsncpy( szName, static_cast<LPCTSTR>(bstrName), ::SysStringLen(bstrName) );

        //aPropVar[cProps].pwszVal =
        //    static_cast<const LPWSTR>(bstrQueName.operator wchar_t*());
        aPropVar[cProps].pwszVal = szQName;
        cProps++;
        // 1
        aPropId[cProps] = PROPID_Q_TYPE;
        aPropVar[cProps].vt = VT_CLSID;
        aPropVar[cProps].puuid = &gMplusQtype;
        cProps++;
        // 2
        aPropId[cProps] = PROPID_Q_LABEL;
        aPropVar[cProps].vt = VT_LPWSTR;
        //aPropVar[cProps].pwszVal = static_cast<const LPWSTR>(bstrName);
        aPropVar[cProps].pwszVal = szName;
        // weixueyuan modify end on 2009-1-7
        cProps++;
        // 3
        propsQueue.cProp = cProps;
        propsQueue.aPropID = static_cast<QUEUEPROPID*>(aPropId);
        propsQueue.aPropVar = static_cast<MQPROPVARIANT*>(aPropVar);
        propsQueue.aStatus = NULL;

        
        // Create the receiving queue.
        // yutianyi modify start on 2010-06-30 for Change Record CFW005&006
        //TraceOutPut( _T("Before ::MQCreateQueue()") );
        /*HRESULT hr = ::MQCreateQueue(
        static_cast<PSECURITY_DESCRIPTOR>(NULL),
        &propsQueue, static_cast<LPWSTR>(wcsFormatName),
        static_cast<LPDWORD>( pdwNumChars ));*/
 /*       //TraceOutPut( _T("After ::MQCreateQueue()") );
        SECURITY_DESCRIPTOR sd;
        // yangke modified start on 2010-9-28 for code review log
        PSID pUserSID=NULL;
        PSID pEveryoneSid = NULL;
        PSID pANONYMOUSSid = NULL;
        PACL pDacl = NULL;
        HRESULT hr = CreateSecurityDescriptorforEveryone( sd, pUserSID, 
            pEveryoneSid, pANONYMOUSSid, pDacl );

        if ( S_OK != hr )
        {
            ReleaseSeurityDescriptor(pUserSID, pEveryoneSid, pANONYMOUSSid, pDacl );
            return MQErrToLocal( hr );
        }
        hr = ::MQCreateQueue( &sd, &propsQueue, 
            static_cast<LPWSTR>( wcsFormatName ),
            static_cast<LPDWORD>( pdwNumChars ));
        // yutianyi modify end on 2010-06-30 for Change Record CFW005&006
        //TraceOutPut( _T("End InnerConnector::CreateQueue()") );
        ReleaseSeurityDescriptor(pUserSID, pEveryoneSid, pANONYMOUSSid, pDacl );
        // yangke  modified end on 2010-9-28 for code review log

        return MQErrToLocal( hr );
    }
    catch (...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        CFW_OUTPUT_ERROR( ERROR_CFW_UNKNOWN_ERROR );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }

}
*/
/**
 * Open a queue
 * @param     bstrName: name of target queue
 * @param     pHandle: handle of queue of opening
 * @param     dwAccess: mode of opening 
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
// yutianyi modify start on 2010-06-21 for Change Record CFW005
/*HRESULT InnerConnector::OpenQueue( const _bstr_t& bstrName,
                                  QUEUEHANDLE& queueHandle,
                                  DWORD dwAccess,
                                  bool bReadOnly )*/
/*
HRESULT InnerConnector::OpenQueue( const _bstr_t& bstrName,
                                  QUEUEHANDLE& queueHandle,
                                  DWORD dwAccess,
                                  bool bReadOnly,
                                  const _bstr_t& bstrHostName )
// yutianyi modify end on 2010-06-21 for Change Record CFW005
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::OpenQueue") );
    try
    {
        //TraceOutPut( _T("Start InnerConnector::OpenQueue()") );
        // Build a formal channel name
        TCHAR szFormatName[MPLUSCFW_MAX_FORMAT_NAME_LEN] =
            MPLUSCFW_EMPTY_STRING;
        ::ZeroMemory( szFormatName, sizeof(szFormatName));
        HRESULT hr = S_OK;
        
        // We should create the queue
        if ( !bReadOnly )
        {
            DWORD dwNumChars = MPLUSCFW_MAX_FORMAT_NAME_LEN ;
            hr = CreateQueue( bstrName, szFormatName, &dwNumChars );
            
            // Check whether operation is success
            if ((FAILED( hr )) && ( ERROR_CFW_CHANNEL_EXIST != hr ))
            {
                // Check error type and return error code
                return hr;
            }
            else if ( ERROR_CFW_CHANNEL_EXIST == hr )
            {
                CreateFormatName( szFormatName, bstrName );
            }
        }
        else
        {
            // Build a format name
            // yutianyi modify start on 2010-06-21 for Change Record CFW005
            //CreateFormatName( szFormatName, bstrName );
            CreateFormatName( szFormatName, bstrName, bstrHostName );
            // yutianyi modify end on 2010-06-21 for Change Record CFW005
        }

        DWORD dwShare = static_cast<DWORD>(MQ_DENY_NONE);

        // In case of receive messages,
        // We should deny other process to receive this channel
        if ((( dwAccess & MQ_RECEIVE_ACCESS ) == MQ_RECEIVE_ACCESS ) ||
            ((( dwAccess & MQ_ADMIN_ACCESS ) == MQ_ADMIN_ACCESS )))
        {
            dwShare = static_cast<DWORD>(MQ_DENY_RECEIVE_SHARE);
        }

        // Call MQ API to open a queue
        //TraceOutPut( _T("Before ::MQOpenQueue()") );
        hr = ::MQOpenQueue( static_cast<LPCWSTR>(szFormatName), dwAccess,
            dwShare, &queueHandle);
        //TraceOutPut( _T("After ::MQOpenQueue()") );

        //TraceOutPut( _T("End InnerConnector::OpenQueue()") );

        return MQErrToLocal(hr);
    }
    catch (...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        CFW_OUTPUT_ERROR( ERROR_CFW_UNKNOWN_ERROR );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
*/
/**
 * Delete a queue
 * @param     bstrName: name of target queue
 * @return    TURE: Delete queue successfully
              FALSE: Delete queue unsuccessfully
 * @since     1.00
 */
/*
HRESULT InnerConnector::DeleteQueue( const _bstr_t& bstrName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::DeleteQueue") );
    try
    {
        WCHAR wcsFormatName[MPLUSCFW_MAX_FORMAT_NAME_LEN ] =
            MPLUSCFW_EMPTY_STRING;
        ::ZeroMemory( wcsFormatName, sizeof(wcsFormatName));

        CreateFormatName( wcsFormatName, bstrName );

        HRESULT hr = ::MQDeleteQueue( static_cast<LPCWSTR>(wcsFormatName));
        return MQErrToLocal( hr );
    }
    catch(...)
    {
        // WeiXueyuan add start on 2008-12-4
        // ProjectID: TMS585
        // BugSource: RC
        // BugID:  RC
        // BugReason: Make CFW event log more clear
        // FixSolution: add more event log info
        CFW_OUTPUT_ERROR( ERROR_CFW_UNKNOWN_ERROR );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
*/
/**
 * Clear a queue
 * @param     bstrName: name of target queue
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
/*
HRESULT InnerConnector::ClearQueue( const _bstr_t& bstrName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ClearQueue") );
    // Validate the parameter.
    if ( !IsValidQueueName( bstrName ))
    {
        return ERROR_CFW_INVALID_PARAMETERS;
    }

    // Open the queue first.
    QUEUEHANDLE hQueue = NULL;
    HRESULT hr = OpenQueue( bstrName, hQueue,
        MQ_RECEIVE_ACCESS | MQ_ADMIN_ACCESS, true );
    if ( FAILED( hr ))
    {
        return ERROR_CFW_FAILED_OPEN;
    }

    // Clear the queue.
    hr = ClearQueue( hQueue );
    // Close the queue
    CloseQueue( hQueue );
    if ( FAILED( hr ))
    {
        return ERROR_CFW_FAILED_CLEAR;
    }
    return hr;
}
*/
/**
 * Clear a queue
 * @param     hQueue: handle of target queue
 * @return    BOOL
 * @since     1.00
 */
/*
HRESULT InnerConnector::ClearQueue( const QUEUEHANDLE& hQueue)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ClearQueue") );
    HRESULT hr = MQErrToLocal( ::MQPurgeQueue( hQueue ));
    return hr;
}
*/
/**
 * Close a queue
 * @param     hQueue: handle of target queue
 * @return    HRESULT:S_OK - closed successfully
 *                    ERROR_CFW_INVALID_PARAMETERS - hQueue are invalid
 * @since     1.00
 */
/*
HRESULT InnerConnector::CloseQueue( const QUEUEHANDLE& hQueue)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CloseQueue") );
    if ( NULL != hQueue )
    {
        // Close handle use MSMQ API
        if ( MQ_OK == ::MQCloseQueue( hQueue ))
        {
            return S_OK;
        }
        else
        {
            // WeiXueyuan add start on 2008-12-4
            // ProjectID: TMS585
            // BugSource: RC
            // BugID:  RC
            // BugReason: Make CFW event log more clear
            // FixSolution: add more event log info
            CFW_OUTPUT_ERROR( ERROR_CFW_FAILED_CLOSE_QUEUE );
            // weixueyuan add end on 2008-12-4
        }
    }
    return ERROR_CFW_INVALID_PARAMETERS;
}
*/
/**
 * Get name of receiving queue
 * @param     void
 * @return    _bstr_t: name of receiving queue
 * @since     1.00
 */
/*
_bstr_t InnerConnector::GetReceiveName()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::GetReceiveName") );
    if ( NULL != m_hRecvQueue )
    {
        return m_bstrRecvQ;
    }
    else
    {
        return MPLUSCFW_EMPTY_STRING;
    }
}
*/
/**
 * Get name of sender
 * @param     void
 * @return    _bstr_t: name of sender
 * @since     1.00
 */
/*
_bstr_t InnerConnector::GetSendName()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::GetSendName") );
    try
    {
        if ( NULL != m_hSendQueue )
        {
            return m_bstrSendQ;
        }
        else
        {
            return _bstr_t( MPLUSCFW_EMPTY_STRING );
        }
    }
    catch (...)
    {
        return _bstr_t( MPLUSCFW_EMPTY_STRING );
    }
}
*/
/**
 * Format version
 * @param     dwVersion: version
 * @return    void
 * @since     1.00
 */
/*
_bstr_t InnerConnector::FormatVersion( DWORD dwVersion )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::FormatVersion") );
    try
    {
        CString csRet = CString( MPLUSCFW_EMPTY_STRING );
        csRet.Format( MPLUSCFW_STRING_VERSION_PREFIX, dwVersion );
        return _bstr_t(static_cast<LPCWSTR>(csRet));
    }
    catch(...)
    {
        return _bstr_t( MPLUSCFW_EMPTY_STRING );
    }
}
*/
// yangke delete end on 20101025 for directory structure change
/**
 * Extract version info from version string
 * @param     bstrVersion: String contain version info
 * @return    DWORD: Version in the string.
 * @since     1.00
 */
DWORD InnerConnector::ParaseVersion( _bstr_t& bstrVersion )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ParaseVersion") );
    try
    {
        DWORD dwRet = MPLUSCFW_VERSION_NUMBER;

        // WeiXueyuan modify start on 2008-12-17
        // ProjectID: TMS585
        // BugSource: 
        // BugID:  
        // BugReason: Modify error checked by c++ test
        // FixSolution: Check pointer
        const wchar_t* pVersion_in = static_cast<const wchar_t *>(bstrVersion);
        const wchar_t* pVersionConst = static_cast<const wchar_t *>(MPLUSCFW_STRING_VERSION_PREFIX);
        if (( NULL == pVersion_in ) || ( NULL == pVersionConst ))
        {
            return MPLUSCFW_CONST_ZERO;
        }
        swscanf( pVersion_in, pVersionConst, &dwRet );
        // weixueyuan modify end on 2008-12-17
        return dwRet;
    }
    catch (...)
    {
        return MPLUSCFW_CONST_ZERO;
    }
}
// yangke delete start on 20101025 for directory structure change
/**
 * Create a formal queue name
 * @param     wcsFormatName: get formal queue name
 * @param     bstrName: name that wants to be converted
 * @return    bool: Does the conversion succeeded.
 * @since     1.00
 */
// yutianyi modify start on 2010-06-18 for Change Record CFW005
/*bool InnerConnector::CreateFormatName( WCHAR* wcsFormatName,
                                      const _bstr_t& bstrName )*/
/*
bool InnerConnector::CreateFormatName( WCHAR* wcsFormatName,
                                      const _bstr_t& bstrName,
                                      const _bstr_t& bstrHostName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CreateFormatName") );
    try
    {
        /*swprintf( wcsFormatName, MPLUSCFW_STRING_FORMATNAME_PREFIX,
            static_cast<const WCHAR*>(::MPLUS::FW::COMM::GetMyComputerName()),
            static_cast<const WCHAR*>(bstrName));*/
/*
        if ( bstrHostName == _bstr_t( MPLUSCFW_EMPTY_STRING ))
        {
            swprintf( wcsFormatName, MPLUSCFW_STRING_FORMATNAME_PREFIX,
                static_cast<const WCHAR*>(::MPLUS::FW::COMM::GetMyComputerName()),
                static_cast<const WCHAR*>(bstrName));
        }
        else
        {
            swprintf( wcsFormatName, MPLUSCFW_STRING_FORMATNAME_PREFIX,
                static_cast<const WCHAR*>(bstrHostName),
                static_cast<const WCHAR*>(bstrName));
        }
        return true;
    }
    catch(...)
    {
        return false;
    }
}
// yutianyi modify end on 2010-06-18 for Change Record CFW005
*/
/**
 * translate the MQ error code into local error code
 * @param     hr: MQ error code
 * @return    HRESULT: local error code
 * @since     1.00
 */
/*
HRESULT InnerConnector::MQErrToLocal( const HRESULT hr )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::MQErrToLocal") );
    switch ( hr )
    {
    case MQ_OK:
        return S_OK;
    case MQ_ERROR_ACCESS_DENIED:
    case MQ_ERROR_WRITE_NOT_ALLOWED:
        return ERROR_CFW_ACCESS_DENIED;
    case MQ_ERROR_IO_TIMEOUT:
        return ERROR_CFW_IO_TIMEOUT;
    case MQ_ERROR_SERVICE_NOT_AVAILABLE:
        return ERROR_CFW_SERVICE_NOT_AVAILABLE;
    case MQ_ERROR_MESSAGE_ALREADY_RECEIVED:
        return ERROR_CFW_MESSAGE_ALREADY_RECEIVED;
    case MQ_ERROR_QUEUE_DELETED:
    case MQ_ERROR_INVALID_HANDLE:
    case MQ_ERROR_OPERATION_CANCELLED:
    case MQ_ERROR_QUEUE_NOT_FOUND:
        return ERROR_CFW_CHANNEL_NOT_EXIST;
    case MQ_ERROR_BUFFER_OVERFLOW:
        return ERROR_CFW_BUFFER_OVERFLOW;
    case MQ_ERROR_QUEUE_EXISTS:
        return ERROR_CFW_CHANNEL_EXIST;
    case MQ_ERROR_ILLEGAL_QUEUE_PATHNAME:
    case MQ_ERROR_INVALID_PARAMETER:
    case MQ_ERROR_ILLEGAL_FORMATNAME:
        return ERROR_CFW_INVALID_PARAMETERS;
    case MQ_ERROR_SHARING_VIOLATION:
        return ERROR_CFW_FAILED_OPEN;
    case MQ_INFORMATION_OPERATION_PENDING:
        return MQ_INFORMATION_OPERATION_PENDING;
    default:
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
*/
// WeiXueyuan add start on 2009-1-7
// ProjectID: TMS604
// BugSource: RC
// BugID:  RC
// BugReason: ASync I/O
// FixSolution: Use ASync I/O
/**
 * Read message from target name
 * @param     hQueue: handle of target queue
 * @param     hExitEvent: handle of exit event
 * @param     pLabel: label of message
 * @param     pMsg: pointer of message
 * @param     dwAction: mode of reading queue
 * @param     lpOverlapped: Pointer to an Overlapped structure.
 *                          Set to NULL for synchronous receive and transactions.
 *                          otherwise asynchronously reading messages
 * @param     bRdOnly: whether the queue is reading only
 * @param     DWORD dwTimeOut: waiting time
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
// yutianyi modify start on 2010-07-14 for Change Record CFW005
/*HRESULT InnerConnector::ReadQueue( const QUEUEHANDLE& hQueue,
                                   HANDLE hExitEvent,
                                   _bstr_t* pbstrLabel,
                                   _bstr_t* pbstrMsg,
                                   DWORD dwAction,
                                   LPOVERLAPPED lpOverlapped,                      
                                   DWORD dwTimeOut )*/
/*
HRESULT InnerConnector::ReadQueue( const QUEUEHANDLE& hQueue,
                                   HANDLE hExitEvent,
                                   HANDLE hStartThread,
                                   _bstr_t* pbstrLabel,
                                   _bstr_t* pbstrFormatName,
                                   _bstr_t* pbstrMsg,
                                   DWORD dwAction,
                                   LPOVERLAPPED lpOverlapped,
                                   DWORD dwTimeOut )
// yutianyi modify end on 2010-07-14 for Change Record CFW005
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ReadQueue") );
    HRESULT hr = S_OK;    
    UCHAR* pBodyBuffer = NULL;
    // Catch exception
    try
    {
        // Validate parameters
        if ( NULL == hQueue  )
        {
            return ERROR_CFW_INVALID_PARAMETERS;
        }
        
        // Message buffer is NULL means delete this message in the queue
        if ( NULL == pbstrMsg )
        {
            // Return HRESULT to display operation result
            return MQErrToLocal( ::MQReceiveMessage(
                hQueue,
                dwTimeOut,
                dwAction,
                static_cast<MQMSGPROPS *>(NULL),
                NULL,
                static_cast<PMQRECEIVECALLBACK>(NULL),
                static_cast<HANDLE>( NULL ),
                static_cast<ITransaction *>(MQ_NO_TRANSACTION)));
        }    
        // Declare properties of MQ
        DWORD cProps = MPLUSCFW_CONST_ZERO;
        MQMSGPROPS propsMessage;
        ::ZeroMemory( &propsMessage, sizeof( propsMessage ));
        // yutianyi modify start on 2010-07-14 for Change Record CFW005
        /*MQPROPVARIANT aPropVar[MPLUSCFW_MQPROPVARIANT_SIZE_SIX];
        ::ZeroMemory( aPropVar, sizeof( aPropVar ));
        MSGPROPID aPropId[MPLUSCFW_MSGPROPID_SIZE_SIX];
        ::ZeroMemory( aPropId, sizeof( aPropId ));
        HRESULT aHr[MPLUSCFW_HRESULT_SIZE_SIX];
        for ( DWORD dwFlag = MPLUSCFW_CONST_ZERO;
        dwFlag < MPLUSCFW_HRESULT_SIZE_SIX; dwFlag++ )
        {
        aHr[dwFlag] = E_FAIL;
        }*/
/*        MQPROPVARIANT aPropVar[MPLUSCFW_MQPROPVARIANT_SIZE_EIGHT];
        ::ZeroMemory( aPropVar, sizeof( aPropVar ));
        MSGPROPID aPropId[MPLUSCFW_MQPROPVARIANT_SIZE_EIGHT];
        ::ZeroMemory( aPropId, sizeof( aPropId ));
        HRESULT aHr[MPLUSCFW_MQPROPVARIANT_SIZE_EIGHT];
        for ( DWORD dwFlag = MPLUSCFW_CONST_ZERO;
            dwFlag < MPLUSCFW_HRESULT_SIZE_EIGHT; dwFlag++ )
        {
            aHr[dwFlag] = E_FAIL;
        }
        // yutianyi modify end on 2010-07-14 for Change Record CFW005
        DWORD dwSize = MPLUSCFW_DEFAULT_RECV_BUFFER_LEN * sizeof( UCHAR );
        pBodyBuffer = new UCHAR[dwSize];
        
        // If pBodyBuffer allocate unsuccessfully, return error code
        if ( NULL == pBodyBuffer )
        {
            return ERROR_CFW_NOT_ENOUGH_MEM;
        }
        ::ZeroMemory( pBodyBuffer, static_cast<size_t>( dwSize*sizeof( UCHAR )));
        
        // Declare and initialize szLabelBuffer
        TCHAR szLabelBuffer[MQ_MAX_Q_NAME_LEN] = MPLUSCFW_EMPTY_STRING;
        ::ZeroMemory( szLabelBuffer, sizeof( szLabelBuffer ));
        UCHAR rgucMsgID[PROPID_M_MSGID_SIZE];
        ::ZeroMemory( rgucMsgID, sizeof( rgucMsgID ));
        
        // Initialize the message 0
        aPropId[cProps] = PROPID_M_BODY;
        aPropVar[cProps].vt = VT_UI1 | VT_VECTOR;
        aPropVar[cProps].caub.pElems = reinterpret_cast<UCHAR *>(pBodyBuffer);
        aPropVar[cProps].caub.cElems = dwSize;
        cProps++;
        // 1
        aPropId[cProps] = PROPID_M_LABEL;
        aPropVar[cProps].vt = VT_LPWSTR;
        aPropVar[cProps].pwszVal = static_cast<LPWSTR>(szLabelBuffer);
        cProps++;
        // 2
        aPropId[cProps] = PROPID_M_BODY_SIZE;
        aPropVar[cProps].vt = VT_UI4;
        cProps++;
        // 3
        aPropId[cProps] = PROPID_M_BODY_TYPE;
        aPropVar[cProps].vt = VT_NULL;
        cProps++;
        // 4
        aPropId[cProps] = PROPID_M_MSGID;                 // Property ID
        aPropVar[cProps].vt = VT_VECTOR | VT_UI1;         // Type indicator
        aPropVar[cProps].caub.pElems = static_cast<UCHAR *>(rgucMsgID);
        aPropVar[cProps].caub.cElems = static_cast<ULONG>(PROPID_M_MSGID_SIZE);
        cProps++;
        // 5
        aPropId[cProps] = PROPID_M_LABEL_LEN;
        aPropVar[cProps].vt = VT_UI4;
        aPropVar[cProps].ulVal = sizeof(szLabelBuffer);
        cProps++;
        // yutianyi add start on 2010-07-14 for Change Record CFW005
        // 6
        TCHAR szFormatNameBuffer[MQ_MAX_Q_NAME_LEN] = MPLUSCFW_EMPTY_STRING;
        ::ZeroMemory( szFormatNameBuffer, sizeof( szFormatNameBuffer ));
        aPropId[cProps] = PROPID_M_RESP_FORMAT_NAME;
        aPropVar[cProps].vt = VT_LPWSTR;
        aPropVar[cProps].pwszVal = static_cast<LPWSTR>(szFormatNameBuffer);
        cProps++;
        // 7
        aPropId[cProps] = PROPID_M_RESP_FORMAT_NAME_LEN;
        aPropVar[cProps].vt = VT_UI4;
        aPropVar[cProps].ulVal = sizeof(szFormatNameBuffer);
        cProps++;
        // yutianyi add end on 2010-07-14 for Change Record CFW005
        // Merge properties
        propsMessage.cProp = cProps;
        propsMessage.aPropID = static_cast<MSGPROPID *>(aPropId);
        propsMessage.aPropVar = static_cast<MQPROPVARIANT *>(aPropVar);
        propsMessage.aStatus = static_cast<HRESULT *>(aHr);
        
        // read from the front of queue first
        hr = ::MQReceiveMessage( hQueue,
            dwTimeOut,
            dwAction,
            &propsMessage,
            lpOverlapped,
            static_cast<PMQRECEIVECALLBACK>( NULL ),
            static_cast<HANDLE>( NULL ),
            static_cast<ITransaction *>( MQ_NO_TRANSACTION ));
        
        hr = MQErrToLocal( hr );
        
        // Check whether it operates successfully
        if ( MQ_INFORMATION_OPERATION_PENDING == hr )
        {
            HANDLE hWaitHandle[WAITOBJECTCOUNT];
            // for exit receiving process
            hWaitHandle[FIRSTOBJECT] = NULL;
            // for receive msg
            hWaitHandle[SECONDOBJECT] = NULL;
            
            hWaitHandle[FIRSTOBJECT] = hExitEvent;
            if ( NULL == hWaitHandle[FIRSTOBJECT] )
            {
                if ( NULL != pBodyBuffer )
                {
                    delete[] pBodyBuffer;
                    pBodyBuffer = static_cast<UCHAR*>( NULL );
                }
                BOOL bCancelIO = ::CancelIo( hQueue );
                if (!bCancelIO)
                {
                    CString csErrorDesc(_T(""));
                    LPVOID lpMsgBuf = NULL;
                    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                        FORMAT_MESSAGE_FROM_SYSTEM | 
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL, GetLastError(), 
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&lpMsgBuf, 0, NULL );
                    csErrorDesc = (LPCTSTR)lpMsgBuf;
                    LocalFree( lpMsgBuf );
                    CFW_OUTPUT_ERROR_STR2( ERROR_CFW_FAILED_CANCEL_IO, csErrorDesc );
                }
                return ERROR_CFW_FAILED_RECV;
            }
            // when this event is signal means receive msg successfully
            hWaitHandle[SECONDOBJECT] = lpOverlapped->hEvent;           
            if ( NULL == hWaitHandle[SECONDOBJECT] )
            {
                if ( NULL != pBodyBuffer )
                {
                    delete[] pBodyBuffer;
                    pBodyBuffer = static_cast<UCHAR*>( NULL );
                }
                BOOL bCancelIO = ::CancelIo( hQueue );
                if ( !bCancelIO )
                {
                    CString csErrorDesc(_T(""));
                    LPVOID lpMsgBuf = NULL;
                    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                        FORMAT_MESSAGE_FROM_SYSTEM | 
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL, GetLastError(), 
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&lpMsgBuf, 0, NULL );
                    csErrorDesc = (LPCTSTR)lpMsgBuf;
                    LocalFree( lpMsgBuf );
                    CFW_OUTPUT_ERROR_STR2( ERROR_CFW_FAILED_CANCEL_IO, csErrorDesc );
                }
                return ERROR_CFW_FAILED_RECV;
            }
            // yutianyi add start on 2010-09-15 for Change Record CFW005
            ::SetEvent(hStartThread);
            // yutianyi add end on 2010-09-15 for Change Record CFW005
            DWORD dResult = ::WaitForMultipleObjects( 
                WAITOBJECTCOUNT, hWaitHandle, FALSE, INFINITE );               
            if ( WAIT_OBJECT_0 == dResult )
            {
                // if ExitEvent is signaled, then exit loop
                if ( NULL != pBodyBuffer )
                {
                    delete[] pBodyBuffer;
                    pBodyBuffer = static_cast<UCHAR*>( NULL );
                }
                BOOL bCancelIO = ::CancelIo( hQueue );
                if (!bCancelIO)
                {
                    CString csErrorDesc(_T(""));
                    LPVOID lpMsgBuf = NULL;
                    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                        FORMAT_MESSAGE_FROM_SYSTEM | 
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL, GetLastError(), 
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&lpMsgBuf, 0, NULL );
                    csErrorDesc = (LPCTSTR)lpMsgBuf;
                    LocalFree( lpMsgBuf );
                    CFW_OUTPUT_ERROR_STR2( ERROR_CFW_FAILED_CANCEL_IO, csErrorDesc );
                }
                return S_FALSE;
            } 
            else if (( WAIT_OBJECT_0 + 1 ) == dResult )
            {  
                hr = MQGetOverlappedResult( lpOverlapped );  
                hr = MQErrToLocal( hr );
                if (FAILED(hr))
                {
                    BOOL bCancelIO = ::CancelIo( hQueue );
                    if ( !bCancelIO )
                    {
                        CString csErrorDesc(_T(""));
                        LPVOID lpMsgBuf = NULL;
                        ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                            FORMAT_MESSAGE_FROM_SYSTEM | 
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL, GetLastError(), 
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR)&lpMsgBuf, 0, NULL );
                        csErrorDesc = ( LPCTSTR )lpMsgBuf;
                        LocalFree( lpMsgBuf );
                        CFW_OUTPUT_ERROR_STR2( ERROR_CFW_FAILED_CANCEL_IO, csErrorDesc );
                    }
                }
            }
            else
            {
                if ( NULL != pBodyBuffer )
                {
                    delete[] pBodyBuffer;
                    pBodyBuffer = static_cast<UCHAR*>(NULL);
                }
                BOOL bCancelIO = ::CancelIo( hQueue );
                if ( !bCancelIO )
                {
                    CString csErrorDesc(_T(""));
                    LPVOID lpMsgBuf = NULL;
                    ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                        FORMAT_MESSAGE_FROM_SYSTEM | 
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL, GetLastError(), 
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR)&lpMsgBuf, 0, NULL );
                    csErrorDesc = (LPCTSTR)lpMsgBuf;
                    LocalFree( lpMsgBuf );
                    CFW_OUTPUT_ERROR_STR2( ERROR_CFW_FAILED_CANCEL_IO, csErrorDesc );
                }
                return ERROR_CFW_FAILED_RECV;
            }
        }
        if ( FAILED( hr ))
        {
            // The size of buffer is not enough
            if ( ERROR_CFW_BUFFER_OVERFLOW == hr )
            {
                // Reallocate memory for pBodyBuffer
                aPropVar[MPLUSCFW_ARRAY_CONUT_FIVE].ulVal =
                    sizeof(szLabelBuffer);
                dwSize = aPropVar[MPLUSCFW_ARRAY_CONUT_TWO].ulVal *
                    sizeof(UCHAR);
                delete[] pBodyBuffer;
                pBodyBuffer = NULL;
                pBodyBuffer = new UCHAR[dwSize];
                if ( NULL == pBodyBuffer )
                {
                    return ERROR_CFW_NOT_ENOUGH_MEM;
                }
                
                // Set MQ properties again
                ::ZeroMemory( pBodyBuffer,
                    static_cast<UINT>(dwSize * sizeof(UCHAR)));
                aPropVar[MPLUSCFW_ARRAY_CONUT_ZERO].caub.cElems =
                    static_cast<ULONG>(dwSize);
                aPropVar[MPLUSCFW_ARRAY_CONUT_ZERO].caub.pElems =
                    pBodyBuffer;
                
                // Execute MQ receive message API
                hr = ::MQReceiveMessage( hQueue,
                    dwTimeOut,
                    dwAction,
                    &propsMessage,
                    static_cast<LPOVERLAPPED>(NULL),
                    static_cast<PMQRECEIVECALLBACK>(NULL),
                    static_cast<HANDLE>(NULL),
                    static_cast<ITransaction *>(MQ_NO_TRANSACTION));                    
                hr = MQErrToLocal( hr );
                // If reading failed, return error code 
                if (FAILED(hr))
                {
                    if ( NULL != pBodyBuffer )
                    {
                        delete[] pBodyBuffer;
                        pBodyBuffer = static_cast<UCHAR*>(NULL);
                    }
                    return hr;
                }
            }
        }
        else
        {
            dwSize = aPropVar[MPLUSCFW_ARRAY_CONUT_TWO].ulVal *
                sizeof( UCHAR );  
        }      
        
        // Return values
        if ( NULL != pbstrMsg )
        {
            // Do we have other way? maybe does not need to allocate a BSTR
            BSTR strtmp = ::SysAllocStringLen(
                reinterpret_cast<const OLECHAR*>( pBodyBuffer ),
                static_cast<UINT>( dwSize / sizeof( OLECHAR )) +
                static_cast<UINT>( dwSize % sizeof( OLECHAR )));
            pbstrMsg->Assign( strtmp );
            ::SysFreeString( strtmp );
        }
        if ( NULL != pbstrLabel )
        {
            *pbstrLabel = szLabelBuffer;
        }
        // yutianyi add start on 2010-07-14 for Change Record CFW005
        if ( NULL != pbstrFormatName )
        {
            *pbstrFormatName = szFormatNameBuffer;
        }
        // yutianyi add end on 2010-07-14 for Change Record CFW005
        if ( NULL != pBodyBuffer )
        {
            delete[] pBodyBuffer;
            pBodyBuffer = static_cast<UCHAR*>( NULL );
        }
        return hr;
    }
    catch( ... )
    {
        if ( NULL != pBodyBuffer )
        {
            delete[] pBodyBuffer;
            pBodyBuffer = static_cast<UCHAR*>(NULL);
        }
        return ERROR_CFW_FAILED_RECV;
    }  
}
*/
// yangke delete end on 20101025 for directory structure change

/**
 * PrepareMsgForQuerySessionList
 * @param     pMessageForQuerySessionList: session list
 * @param     bstrQueueName: queue name
 * @param     bstrMsg: the message info
 * @param     bstrConnectName: connect queue name
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
BOOL InnerConnector::PrepareMsgForQuerySessionList(IMplusMessage* pMessageForQuerySessionList, const _bstr_t& bstrQueueName, _bstr_t& bstrMsg, _bstr_t bstrConnectName)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::PrepareMsgForQuerySessionList") );
    ////////////////////////////////////////////
    // message
    pMessageForQuerySessionList->SetCommand( _bstr_t(static_cast<LPCWSTR>(
        MPLUSCFW_BCMSGTYPE_QUERYHOSTINFO )));
    pMessageForQuerySessionList->SetParameter( bstrConnectName);
    pMessageForQuerySessionList->SetCustom( _bstr_t(static_cast<LPCWSTR>(MPLUSCFW_EMPTY_STRING)));
    pMessageForQuerySessionList->SetTimeOut( MPLUSCFW_CHECK_Q_TIMEOUT );
    // Validate message address
    pMessageForQuerySessionList->SetFromAddress( m_bstrRecvQ );
    pMessageForQuerySessionList->SetToAddress( bstrQueueName );
    pMessageForQuerySessionList->SetHostName( m_bstrMyHostName );
    m_bSendSyncMsg = true;
     

    // Set message priority
    pMessageForQuerySessionList->SetCallType( CFW_CALLTYPE_SYNC );

    DWORD dwTick = GetTickCount();
    WCHAR strTick[MPLUSCFW_WCHARARRAY_SIZE] = MPLUSCFW_EMPTY_STRING;

    // Prepare message property
    swprintf( strTick, _T( "%u" ), dwTick );
    pMessageForQuerySessionList->SetTimeStamp( _bstr_t( strTick ) );

    // If timeout is not set, set infinite
    if ( MPLUSCFW_TIMEOUT_NOWAIT == pMessageForQuerySessionList->GetTimeOut())
    {
        pMessageForQuerySessionList->SetTimeOut( static_cast<DWORD>(INFINITE));
    }
    // Set UID for message
    UINT64 unMsgUID = ::MPLUS::FW::COMM::GetMessageUID();
    pMessageForQuerySessionList->SetUID( unMsgUID );

    // Encode message
    bstrMsg = SerializeMsg( pMessageForQuerySessionList );
    if (CFW_CALLTYPE_SYNC == pMessageForQuerySessionList->GetCallType())
    {
        m_uUidForSyncMessage =  pMessageForQuerySessionList->GetUID();
    }
    return true;
}
/**
 * Check a Global unique ID for queue name
 * @param     void
 * @return    CString: queue name.
 * @since     1.00
*/
CString InnerConnector::BuildGUIDQueueName()
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::BuildGUIDQueueName") );
    try
    {
        GUID stQueueID;
        if ( FAILED( CoCreateGuid( &stQueueID )))
        {
            return MPLUSCFW_EMPTY_STRING;
        }
        CString csQueueID( MPLUSCFW_EMPTY_STRING );
        //DWORD dwCurrentSessionID;
        //::ProcessIdToSessionId( ::GetCurrentProcessId(), &dwCurrentSessionID );
        /**
        * Modified for MPlus V4
        * @since 1.10
        */
        /// To fix the CString::Format() function issue in x64 configuration. In x64 configuration 
        /// CString::Format() creates a string with content as end memory address of the stQueueID struct.
        // csQueueID.Format( PERCENT_D, stQueueID );
        csQueueID.Format( PERCENT_D, stQueueID.Data1);
        /**
        * End of Modification for MPlus V4
        */
        //csQueueID = csQueueID;

        return csQueueID;
        /*TCHAR szPcName[MAX_PATH] = MPLUSCFW_EMPTY_STRING;
        DWORD dwSize = sizeof(szPcName);
        ::ZeroMemory( szPcName, dwSize );

        CString csPcName( MPLUSCFW_EMPTY_STRING );
        if ( ::GetComputerName( static_cast<LPWSTR>(szPcName), &dwSize ))
        {
            csPcName = szPcName;
        }
        else
        {
            csPcName = MPLUSCFW_COMPUTERNAME_DOT;
        }
        // yutianyi add start on 2010-06-09 for Change Record CFW004
        m_bstrRecvQ = (_bstr_t)csQueueID;
        // yutianyi add end on 2010-06-09 for Change Record CFW004
        CString csQueue = csPcName + PRIVATE$ + csQueueID;
        return csQueue;*/
    }
    catch (...)
    {
        MPLUS_TRACE_ERROR( _T( "Error: unexpected error" ));
        CFW_OUTPUT_ERROR( ERROR_CFW_UNKNOWN_ERROR );
        return MPLUSCFW_EMPTY_STRING;
    }
}
// yutianyi add end on 2010-09-15 for Change Record CFW005

// yutianyi add start on 2010-06-09 for Change Record CFW003&004&005&006
/**
 * Get all queue names
 * @param     bstrName: [in], the original queue name
 * @param     bstrHostName: [in], the host name
 * @param     csArrQNames: [out], the queue name array
 * @return    HRESULT: an error code if failed, S_OK if succeed.
 * @since     1.00
 */
HRESULT InnerConnector::GetAllQueueNames( _bstr_t bstrName, 
                                         _bstr_t bstrHostName,
                                         CStringArray &csArrQNames )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::GetAllQueueNames") );
    PLUID sessions = NULL;
    HANDLE hServer = NULL;
    PWTS_SESSION_INFO pSessionInfo = NULL;
    try
    {
        CString csHostName = (LPCTSTR)bstrHostName;
        CString csMyHostName = (LPCTSTR)m_bstrMyHostName;
        // yangke modified start on 2010-9-28 for AT bug
        //if ( bstrHostName == _bstr_t(MPLUSCFW_EMPTY_STRING) || 
        //    bstrHostName == m_bstrMyHostName )
        if ( csHostName.CompareNoCase(_T(""))==0 || 
            csHostName.CompareNoCase(csMyHostName)==0 )
        // yangke  modified end on 2010-9-28 for AT bug
        {
            bstrHostName = MPLUSCFW_EMPTY_STRING;
            DWORD dCount = 0;
            BOOL bReturn = FALSE;
            PWTS_SESSION_INFO pSessionInfo = NULL; // local Sessions
            bReturn = WTSEnumerateSessions( WTS_CURRENT_SERVER_HANDLE, 0, 1, &pSessionInfo, 
                &dCount);
            if ( FALSE == bReturn || NULL == pSessionInfo )
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, stErrorDetail );
                return E_FAIL;
            }

            csArrQNames.RemoveAll();
            CString csRecvQ = (LPCTSTR)m_bstrRecvQ;
            for  (DWORD i = 0; i < dCount; i++ )
            {
                int nSessionId = pSessionInfo[i].SessionId;
                CString csQName;
                csQName.Format( MPLUSCFW_QUEUE_FORMAT, (LPCTSTR)bstrName, nSessionId );
//              if ( (LPCTSTR)m_bstrRecvQ == csQName )
                // sunyongjie modified start on 20101018 for tmsc review log
                if ( csRecvQ.CompareNoCase( csQName ) == 0)
                // sunyongjie modified end on 20101018 for tmsc review log
                {
                    continue;
                }
                bool bExist = false;
                for ( int j = 0; j < csArrQNames.GetSize(); j++ )
                {
                    if ( csQName == csArrQNames.GetAt(j) )
                    {
                        bExist = true;
                        continue;
                    }
                }
                if ( !bExist )
                {
                    csArrQNames.Add( csQName );
                }
            }
            WTSFreeMemory( pSessionInfo );
        }
        // yutianyi add start on 2010-07-05 for Change Record CFW003&004&005&006
        else // across host
        {
            QUEUEHANDLE hQueueHandle;
            if ( NULL == m_pMessageRet )
            {
                m_pMessageRet = MPlusMessageFactory::CreateMessage();
                if (NULL == m_pMessageRet)
                {
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("GetAllQueueNames");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                    return E_FAIL;
                }
            }
            // get handle
            _bstr_t bstrQueueName = MPLUSCFW_QUERYHOSTINFO;
            if (S_OK != OpenQueue( bstrQueueName, hQueueHandle, MQ_SEND_ACCESS, TRUE, bstrHostName ))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                return E_FAIL;
            }
            // get message
            IMplusMessage *pMessageIn = MPlusMessageFactory::CreateMessage();
            // sunyongjie add start on 20101018 for tmsc review log
            if (NULL == pMessageIn)
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                return E_FAIL;
            }
            // sunyongjie add end on 20101018 for tmsc review log
            _bstr_t bstrMsg;
            if (!PrepareMsgForQuerySessionList(pMessageIn, bstrQueueName, bstrMsg, bstrName))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                if(pMessageIn)
                {
                    MPlusMessageFactory::DestroyMessage(pMessageIn);
                }
                return E_FAIL;
            }
            ::ResetEvent( m_hSendSyncEvent ); 
            /////////////////////////////////////////////////////////////
            // get queue name
            _bstr_t bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            ////need receive some inside message we must ensure has a receive queue X.
            //bool bCurrentListenStatus = IsListening();
            //if(false == bCurrentListenStatus)
            //{
            //    //this queue only recv inside message after received delete it.
            //    CString csTempRecvQueue = BuildGUIDQueueName();
            //    ::ResetEvent(m_hThreadStartEvent);
            //    ListenForTempQueue(_bstr_t(csTempRecvQueue));
            //    WaitForSingleObject(m_hThreadStartEvent,INFINITE);
            //}

            if(MPLUSCFW_CONST_ZERO == m_bstrRecvQ.length())
            {
                bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            }
            else
            {
                CString csFormatName = MPLUSCFW_EMPTY_STRING;
                csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                    (LPTSTR)m_bstrMyHostName, (LPTSTR)m_bstrRecvQ );
                bstrFormatName = _bstr_t(static_cast<LPCWSTR>(csFormatName));
            }
            int nPriorty = MPLUSCFW_PRIORITY_SYNC;

            /////////////////////////////////////////////////////////
            // send message for sessionlist
            HRESULT hr;
            hr = SendMsg( hQueueHandle,
                FormatVersion( MPLUSCFW_COMM_VERSION ),
                bstrMsg, nPriorty, pMessageIn->GetTimeOut(), bstrFormatName);
            // sunyongjie add start on 20101018 for tmsc review log
            if ( FAILED( hr ))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                return E_FAIL;
            }
            // sunyongjie add end on 20101018 for tmsc review log
            /////////////////////////////////////////////////////////////////////////
            // 


            HANDLE hWaitHandle[WAITOBJECTCOUNT];
            hWaitHandle[FIRSTOBJECT] = m_hSendSyncEvent;
            hWaitHandle[SECONDOBJECT] = m_hSendSyncAbortEvent; 

            DWORD dResult = ::WaitForMultipleObjects( 
                WAITOBJECTCOUNT, hWaitHandle, FALSE, TIMEOUT_GETALLSESSIONLIST ); 


            DWORD dCount = 0;
            int* arrSessionList = NULL;
            if ( WAIT_OBJECT_0 == dResult )
            {  
                // yangke modified start on 2010-9-28 for code review log
                // session ID and amount of Sessions
                BOOL bRet = QuerySessionList(arrSessionList, (int&)dCount);
                if(bRet != TRUE)
                {   
                    // sunyongjie add start on 20101018 for tmsc review log
                    ErrorDetail stErrorDetail;
                    CString cTemp = _T("GetAllQueueNames");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                    CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                    // sunyongjie add end on 20101018 for tmsc review log
                    return ERROR_CFW_FAILED_RECV;
                }
                // yangke  modified end on 2010-9-28 for code review log
            }
            else if ( WAIT_OBJECT_0 +1 == dResult )
            {
                // Should notify other the call is aborted
                // sunyongjie add start on 20101018 for tmsc review log
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                // sunyongjie add end on 20101018 for tmsc review log
                return ERROR_CFW_USERABORT;
            }
            else if( WAIT_TIMEOUT == dResult)
            { 
                m_pMessageRet = NULL;
                // sunyongjie add start on 20101018 for tmsc review log
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_WAITTIMEOUT, stErrorDetail );
                // sunyongjie add end on 20101018 for tmsc review log
                hr = ERROR_CFW_WAITTIMEOUT;
                return hr;
            }
            else
            {
                // sunyongjie add start on 20101018 for tmsc review log
                ErrorDetail stErrorDetail;
                CString cTemp = _T("GetAllQueueNames");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, stErrorDetail );
                // sunyongjie add end on 20101018 for tmsc review log
                return ERROR_CFW_FAILED_RECV;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // all queue names
            for ( DWORD i = 0; i < dCount; i++ )
            {

                CString csQName;
                csQName.Format( MPLUSCFW_QUEUE_FORMAT, (LPCTSTR)bstrName, arrSessionList[i] );
                bool bExist = false;
                for ( int j = 0; j < csArrQNames.GetSize(); j++ )
                {
                    if ( csQName == csArrQNames.GetAt(j) )
                    {
                        bExist = true;
                        continue;
                    }
                }
                if ( !bExist )
                {
                    csArrQNames.Add( csQName );
                }

            }
            // yangke modified start on 2010-9-28 for code review log
            if(pMessageIn)
            {
                MPlusMessageFactory::DestroyMessage(pMessageIn);
                //pMessageIn = NULL;
            }
            if(arrSessionList != NULL)
            {
                delete[] arrSessionList;
                arrSessionList = NULL;         
            }
            // yangke  modified end on 2010-9-28 for code review log
        }
        // yutianyi add end on 2010-07-05 for Change Record CFW003&004&005&006
        return S_OK;
    }
    catch ( ... )
    {
        if ( NULL != sessions )
        {
            LsaFreeReturnBuffer(sessions);
        }
        if ( NULL != hServer )
        {
            WTSCloseServer( hServer );
        }
        if ( NULL != pSessionInfo )
        {
            WTSFreeMemory(pSessionInfo);
        }
        ErrorDetail stErrorDetail;
        CString cTemp = _T("GetAllQueueNames");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_LIST_ALL_SESSIONIDS, 
            stErrorDetail );
        return ERROR_CFW_LIST_ALL_SESSIONIDS;
    }
}

/**
* Send multi message, whether the message is synchronous or asynchronous
* @param     messageIn: message that is waiting for sending
* @param     dwCallType: mode of sending
* @return    HRESULT: a error code if failed, S_OK if succeed.
* @since     1.00
*/
HRESULT InnerConnector::SendMultiCommon( IMplusMessage* pMsgIn,
                                   const DWORD dwCallType )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendMultiCommon") );
    try
    {
        // yangke modified start on 2010-9-28 for code review log
        if (0 == m_validQueueArr.size())
        {
            return ERROR_CFW_FAILED_NOT_CONNECTED;
        }
        // yangke  modified end on 2010-9-28 for code review log

        // Make sure we have connect to the channel

        // [TCH_Li Jinguo] [add] start on 2010-10-22
        // BugReason: Make sure CFW source code of MPlus V5 can be compliled by Visual C++ 6.0
        // FixSolution: define variable ahead of time 
        UINT i =0;
		// [TCH_Li Jinguo] [add] end on 2010-10-22
        for ( i = 0; i < m_validQueueArr.size(); i++ )
        {
            if ( !IsConnected(m_validQueueArr[i].hQueueHandle) )
            {
                ErrorDetail stErrorDetail;
                if ( dwCallType == CFW_CALLTYPE_SYNC )
                {
                    CString cTemp = _T("SendSync");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                }
                else if ( dwCallType == CFW_CALLTYPE_ASYNC )
                {
                    CString cTemp = _T("SendASync");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                }
                CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_validQueueArr[i].bstrQueueName, MAX_LENGTH -InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgIn->GetCommand(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
                stErrorDetail.uUID = pMsgIn->GetUID();
                stErrorDetail.uReUID = pMsgIn->GetReUID();
                stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_NOT_CONNECTED, 
                    stErrorDetail );
                //return ERROR_CFW_FAILED_NOT_CONNECTED;
                ::MQCloseQueue( m_validQueueArr[i].hQueueHandle );
                m_validQueueArr[i].hQueueHandle = NULL;
                m_validQueueArr.erase(m_validQueueArr.begin() + i);
                i--;
            }
        }

        // yangke modified start on 2010-9-28 for code review log
        if (0 == m_validQueueArr.size()) // something happened between connect and send
        {
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendMultiCommon");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_NOT_CONNECTED, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return ERROR_CFW_FAILED_NOT_CONNECTED;
        }
        // yangke  modified end on 2010-9-28 for code review log

        // Validate parameter
        if ( NULL == pMsgIn )
        {
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T("SendASync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            //CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_PARAMETERS, 
                stErrorDetail );
            return ERROR_CFW_INVALID_PARAMETERS;
        }

        // Validate the message
        if ( !IsValidSendMessage( pMsgIn ))
        {
            ErrorDetail stErrorDetail;
            if ( dwCallType == CFW_CALLTYPE_SYNC )
            {
                CString cTemp = _T("SendSync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            else if ( dwCallType == CFW_CALLTYPE_ASYNC )
            {
                CString cTemp = _T("SendASync");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            }
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
            //CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = pMsgIn->GetUID();
            stErrorDetail.uReUID = pMsgIn->GetReUID();
            stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_COMMAND_IS_EMPTY, 
                stErrorDetail );
            return ERROR_CFW_COMMAND_IS_EMPTY;
        }
        unsigned long countForFailedSendMulti = 0;
        for ( i = 0; i < m_validQueueArr.size(); i++ )
        {
            // Validate message address
            if ( !IsValidQueueName( pMsgIn->GetFromAddress()))
            {
                pMsgIn->SetFromAddress( m_bstrRecvQ );
            }
            if ( !IsValidQueueName( pMsgIn->GetToAddress()))
            {
                //pMsgIn->SetToAddress( m_bstrSendQ );
                pMsgIn->SetToAddress( m_validQueueArr[i].bstrQueueName );
            }

            // Set message priority
            pMsgIn->SetCallType( dwCallType );

            DWORD dwTick = GetTickCount();
            WCHAR strTick[MPLUSCFW_WCHARARRAY_SIZE] = MPLUSCFW_EMPTY_STRING;

            // Prepare message property
            swprintf( strTick, _T( "%u" ), dwTick );
            pMsgIn->SetTimeStamp( _bstr_t( strTick ));

            // If timeout is not set, set infinite
            if ( MPLUSCFW_TIMEOUT_NOWAIT == pMsgIn->GetTimeOut())
            {
                pMsgIn->SetTimeOut( static_cast<DWORD>(INFINITE));
            }

            // Set UID for message
            UINT64 unMsgUID = ::MPLUS::FW::COMM::GetMessageUID();
            pMsgIn->SetUID( unMsgUID );
            m_validQueueArr[i].uUid = unMsgUID;
            m_validQueueArr[i].bState = false;

            // yutianyi add start on 2010-06-17 for Change Record CFW005
            // Set computer name for message
            pMsgIn->SetHostName( m_bstrMyHostName );
            // yutianyi add end on 2010-06-17 for Change Record CFW005

            // Encode message
            _bstr_t bstrMsg = SerializeMsg( pMsgIn );

            // Bad message format
            if ( MPLUSCFW_EMPTYSTRING_LEN == bstrMsg.length())
            {
                ErrorDetail stErrorDetail;
                if ( dwCallType == CFW_CALLTYPE_SYNC )
                {
                    CString cTemp = _T("SendSync");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                }
                else if ( dwCallType == CFW_CALLTYPE_ASYNC )
                {
                    CString cTemp = _T("SendASync");
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                }
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_validQueueArr[i].bstrQueueName, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_BAD_MESG_FORMAT, 
                    stErrorDetail );
                return ERROR_CFW_BAD_MESG_FORMAT;
            }
            int nPriorty = ( CFW_CALLTYPE_ASYNC == dwCallType ) ?
                            MPLUSCFW_PRIORITY_ASYNC : MPLUSCFW_PRIORITY_SYNC;

            // Send message
            // yutianyi modify start on 2010-07-15 for Change Record CFW005
            /*HRESULT hr = SendMsg( m_validQueueArr[i].hQueueHandle,
                FormatVersion( MPLUSCFW_COMM_VERSION ),
                bstrMsg, nPriorty, pMsgIn->GetTimeOut());*/
            //yangke 20100817 start
            _bstr_t bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            if(MPLUSCFW_CONST_ZERO == m_bstrRecvQ.length() &&
                pMsgIn->GetFromAddress().length() == MPLUSCFW_CONST_ZERO)
            {
                bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            }
            else
            {
                bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
                CString csFormatName = MPLUSCFW_EMPTY_STRING;
                if(pMsgIn->GetFromAddress().length() != MPLUSCFW_CONST_ZERO)
                {
                    if(pMsgIn->GetSessionId().length()!=MPLUSCFW_CONST_ZERO)
                    {   
                        CString csFullQueueName = MPLUSCFW_EMPTY_STRING;
                        csFullQueueName.Format(_T("%s_%s"),(LPTSTR)pMsgIn->GetFromAddress()
                        ,(LPTSTR)pMsgIn->GetSessionId());
                        csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                            (LPTSTR)m_bstrMyHostName, csFullQueueName);
                    }
                    else
                    {
                        csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                            (LPTSTR)m_bstrMyHostName, (LPTSTR)pMsgIn->GetFromAddress());
                    }

                }
                else
                {
                    csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                        (LPTSTR)m_bstrMyHostName, (LPTSTR)m_bstrRecvQ );
                }
                bstrFormatName = _bstr_t(static_cast<LPCWSTR>(csFormatName));

            }
            //yangke 20100817 end
            HRESULT hr = SendMsg( m_validQueueArr[i].hQueueHandle,
                FormatVersion( MPLUSCFW_COMM_VERSION ),
                bstrMsg, nPriorty, pMsgIn->GetTimeOut(), bstrFormatName ); 
            // yutianyi modify end on 2010-07-15 for Change Record CFW005
            if ( FAILED( hr ))
            {
                countForFailedSendMulti++;
                ErrorDetail stErrorDetail;
                if ( dwCallType == CFW_CALLTYPE_SYNC )
                {
                    CString cTemp = _T( "SendSync" );
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                }
                else if ( dwCallType == CFW_CALLTYPE_ASYNC )
                {
                    CString cTemp = _T( "SendASync" );
                    CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                }
                CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_validQueueArr[i].bstrQueueName, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgIn->GetCommand(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
                stErrorDetail.uUID = pMsgIn->GetUID();
                stErrorDetail.uReUID = pMsgIn->GetReUID();
                stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_SEND, 
                    stErrorDetail );
                if(dwCallType == CFW_CALLTYPE_SYNC)
                {
                    return ERROR_CFW_FAILED_SEND;
                }
            }
        }

        //TraceOutPut( _T("End: InnerConnector::SendMultiCommon()") );
        if ( countForFailedSendMulti == m_validQueueArr.size() )
        {
            return ERROR_CFW_FAILED_SEND;
        }
        else
        {
            return S_OK;
        }
    }
    catch (...)
    {
        ErrorDetail stErrorDetail;
        if ( dwCallType == CFW_CALLTYPE_SYNC )
        {
            CString cTemp = _T("SendSync");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        }
        else if ( dwCallType == CFW_CALLTYPE_ASYNC )
        {
            CString cTemp = _T("SendASync");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        }
        CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgIn->GetSender(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)m_bstrSendQ, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgIn->GetCommand(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cParameter, (LPCTSTR)pMsgIn->GetParameter(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cCustom, (LPCTSTR)pMsgIn->GetCustom(), MAX_LENGTH - InitOne );
        stErrorDetail.uUID = pMsgIn->GetUID();
        stErrorDetail.uReUID = pMsgIn->GetReUID();
        stErrorDetail.dTimeOut = pMsgIn->GetTimeOut();
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, 
            stErrorDetail );
        // weixueyuan add end on 2008-12-4
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
// yutianyi add end on 2010-06-09 for Change Record CFW003&004&005&006

// yangke delete start on 20101025 for directory structure change
// yutianyi add start on 2010-06-30 for Change Record CFW005&006
/**
* Retrieve String SID
* @param     CString: domain name
* @param     CString: user name
* @param     PSID: pointer of SID structure
* @return    HRESULT: a error code if failed, S_OK if succeed.
* @since     1.00
*/
/*
HRESULT InnerConnector::RetrieveStringSidByUserName(
    const CString& csDomainName, const CString& csUserName, PSID& pSid )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::RetrieveStringSidByUserName") );
    HRESULT hr = S_OK;

    TCHAR szReferencedDomain[MAX_PATH];
    DWORD dwSidSize = 0;
    DWORD dwReferencedDomainSize = 0;
    SID_NAME_USE accountType;
    CString csQualifiedUserName;
    LPWSTR pszStringSid = NULL;

    // generate qualified user name firstly
    csQualifiedUserName.Format(L"%s\\%s", csDomainName, csUserName);
    ZeroMemory(szReferencedDomain, MAX_PATH * sizeof(TCHAR));

    // try to allocate memory for SID structure
    pSid = (PSID)HeapAlloc(GetProcessHeap(),  HEAP_ZERO_MEMORY, 128);
    if ( NULL == pSid )
    {
        return E_FAIL;
    }

    // generate string SID via domain name and user name
    if (!LookupAccountName(NULL, csQualifiedUserName, pSid, &dwSidSize, szReferencedDomain, &dwReferencedDomainSize, &accountType))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            pSid = (PSID)HeapReAlloc(GetProcessHeap(),  HEAP_ZERO_MEMORY, pSid, dwSidSize);
            if ( NULL == pSid )
            {
                return E_FAIL;
            }

            if (!LookupAccountName(NULL, csQualifiedUserName, pSid, &dwSidSize, szReferencedDomain, &dwReferencedDomainSize, &accountType))
            {
                HeapFree(GetProcessHeap(), 0, pSid);
                return E_FAIL;
            }
        }
    }

    // convert SID to SID string
    BOOL bSucceeded = ConvertSidToStringSid(pSid, &pszStringSid);
    // yangke modified start on 2010-9-28 for code review log
    if (bSucceeded)
    {
        ;
    }
    else
    {
        hr = E_FAIL;
    }
    LocalFree(pszStringSid);
    // yangke  modified end on 2010-9-28 for code review log
    return hr;
}
*/
// yutianyi add start on 2010-09-15 for Change Record CFW005
/**
 * Check Current User
 * @param     VOID
 * @return    HRESULT: a error code if failed, S_OK if succeed.
 * @since     1.00
 */
/*
CString InnerConnector::CheckCurrentUser()
{
    // yangke modified start on 2010-9-28 for code review log
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CheckCurrentUser") );
    TCHAR  infoBuf[MPLUSCFW_MAX_USERNAME_LEN];
    DWORD  bufCharCount = MPLUSCFW_MAX_USERNAME_LEN;
    // yangke  modified end on 2010-9-28 for code review log
    CString csUserName;
    GetUserName(infoBuf, &bufCharCount);
    csUserName = infoBuf;
    DWORD dwLevel = 0;
    DWORD dwFlags = LG_INCLUDE_INDIRECT;
    DWORD dwPrefMaxLen = MAX_PREFERRED_LENGTH;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    LPLOCALGROUP_USERS_INFO_0 pBuf = NULL;
    LPLOCALGROUP_USERS_INFO_0 pTmpBuf = NULL;
    NET_API_STATUS nStatus;

    nStatus = NetUserGetLocalGroups(NULL,
        csUserName,
        dwLevel,
        dwFlags,
        (LPBYTE *) &pBuf,
        dwPrefMaxLen,
        &dwEntriesRead,
        &dwTotalEntries);
    pTmpBuf = pBuf;

    if(nStatus!=NERR_Success)
    {
        // yangke modified start on 2010-9-28 for code review log
        NetApiBufferFree(pBuf);
        // yangke  modified end on 2010-9-28 for code review log
        return csUserName;
    }
    for(DWORD i = 0; i < dwEntriesRead; i++)
    {
        if (pTmpBuf == NULL)
        {
        
            return csUserName;
        }
        CString csGroup =pTmpBuf->lgrui0_name;
        if(csGroup.CompareNoCase(_T("TMSCMED")) == 0)
        {
            NetApiBufferFree(pBuf);
            return _T("TMSCMED");
        }
        pTmpBuf++;
    }
    // yangke modified start on 2010-9-28 for code review log
    NetApiBufferFree(pBuf);
    // yangke  modified end on 2010-9-28 for code review log
    return csUserName;

}
*/
/**
* RealeseDescriptor
* @param     PSID: SID for everyone
* @param     PSID: SID for anonymous
* @return    HRESULT: a error code if failed, S_OK if succeed.
* @since     1.00
*/
/*
// yangke modified start on 2010-9-28 for code review log
HRESULT InnerConnector::ReleaseSeurityDescriptor(PSID &pUserSID, PSID &pEveryoneSid, PSID &pANONYMOUSSid,PACL &pDacl)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ReleaseSeurityDescriptor") );
    if(pUserSID)
    {
        FreeSid(pUserSID);
        pUserSID = NULL;
    }
    if(pEveryoneSid )
    {
        FreeSid(pEveryoneSid);
        pEveryoneSid = NULL;
    }
    if(pANONYMOUSSid)
    {
        FreeSid(pANONYMOUSSid);
        pANONYMOUSSid = NULL;
    }
    if(pDacl)
    {
        delete[] pDacl;
        pDacl=NULL;
    }
    return S_OK;
}
*/
// yangke  modified end on 2010-9-28 for code review log
/**
* CreateSecurityDescriptor
* @param     SECURITY_DESCRIPTOR: security description of queue
* @param     PSID: SID for user
* @param     PSID: SID for everyone
* @param     PSID: SID for anonymous
* @return    HRESULT: a error code if failed, S_OK if succeed.
* @since     1.00
*/
/*
HRESULT InnerConnector::CreateSecurityDescriptorforEveryone(
    SECURITY_DESCRIPTOR &sd, PSID &pUserSID, PSID &pEveryoneSid, PSID &pANONYMOUSSid,PACL &pDacl )
{
    //PSID pUserSID=NULL;
    //PSID pEveryoneSid = NULL;
    //PSID pANONYMOUSSid = NULL;
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::CreateSecurityDescriptorforEveryone") );
    DWORD cbDacl = 0;
    //PACL pDacl = NULL;

    try
    {
        // SECURITY_DESCRIPTOR sd;
        // Retrieve the SID of the Everyone group.
        SID_IDENTIFIER_AUTHORITY siaAnonymous = SECURITY_NT_AUTHORITY;
        SID_IDENTIFIER_AUTHORITY siaEveryOne = SECURITY_WORLD_SID_AUTHORITY;
       
        //for Anonymous
        if (AllocateAndInitializeSid(
            &siaAnonymous,          // Top-level SID authority
            1,                   // Number of subauthorities
            SECURITY_ANONYMOUS_LOGON_RID,  // Subauthority value
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &pANONYMOUSSid        // SID returned as OUT parameter
            ) == FALSE)
        {
            //error;
            // yangke modified start on 2010-9-28 for code review log
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            // yangke  modified end on 2010-9-28 for code review log
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            return E_FAIL;
        }
        //for everyone
        if (AllocateAndInitializeSid(
            &siaEveryOne,          // Top-level SID authority
            1,                   // Number of subauthorities
            SECURITY_WORLD_RID,  // Subauthority value
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            &pEveryoneSid        // SID returned as OUT parameter
            ) == FALSE)
        {
            //error;
            // yangke modified start on 2010-9-28 for code review log
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            // yangke  modified end on 2010-9-28 for code review log
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            return E_FAIL;
        }

        CString csUserOrGroupName = CheckCurrentUser();
        CString csDomain;
        CString csUname;

        HRESULT hRet = RetrieveStringSidByUserName(csDomain,csUserOrGroupName,pUserSID);
        if(hRet !=S_OK)
        {
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            return E_FAIL;
        }

        // Calculate the amount of memory that must be allocated for the DACL.
        cbDacl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE)*3 - sizeof(DWORD)*3;
        cbDacl += GetLengthSid(pANONYMOUSSid);
        cbDacl += GetLengthSid(pEveryoneSid);
        cbDacl += GetLengthSid(pUserSID);
        
        pDacl = (PACL) new BYTE[cbDacl];
        memset(pDacl, 0, cbDacl);
        if (InitializeAcl(
            pDacl,
            cbDacl,
            ACL_REVISION  // Required constant
            ) == FALSE)
        {
            // yangke modified start on 2010-9-28 for code review log
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            // yangke  modified end on 2010-9-28 for code review log
            return E_FAIL;
        }

        if (AddAccessAllowedAce(
            pDacl,                    // Pointer to the ACL.
            ACL_REVISION,             // Required constant
            MQSEC_WRITE_MESSAGE,  // Access mask
            pANONYMOUSSid      // Pointer to the trustee's SID
            ) == FALSE)
        {
            //error;
            // yangke modified start on 2010-9-28 for code review log
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            // yangke  modified end on 2010-9-28 for code review log
            return E_FAIL;
        }


        if (AddAccessAllowedAce(
            pDacl,                    // Pointer to the ACL.
            ACL_REVISION,             // Required constant
            MQSEC_QUEUE_GENERIC_WRITE,  // Access mask
            pEveryoneSid      // Pointer to the trustee's SID
            ) == FALSE)
        {
            //error;
            // yangke modified start on 2010-9-28 for code review log
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            // yangke  modified end on 2010-9-28 for code review log
            return E_FAIL;
        }


        if (AddAccessAllowedAce(
            pDacl,                    // Pointer to the ACL.
            ACL_REVISION,             // Required constant
            MQSEC_RECEIVE_MESSAGE | 
            MQSEC_RECEIVE_JOURNAL_MESSAGE |
            MQSEC_SET_QUEUE_PROPERTIES |
            MQSEC_GET_QUEUE_PROPERTIES |
            MQSEC_DELETE_QUEUE |
            MQSEC_GET_QUEUE_PERMISSIONS |
            MQSEC_CHANGE_QUEUE_PERMISSIONS |
            MQSEC_TAKE_QUEUE_OWNERSHIP,  // Access mask
            pUserSID      // Pointer to the trustee's SID
            ) == FALSE)
        {
            //error;
            // yangke modified start on 2010-9-28 for code review log
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            // yangke  modified end on 2010-9-28 for code review log
            return E_FAIL;

        }
        
        // Initialize an absolute SECURITY_DESCRIPTOR structure.
        if (InitializeSecurityDescriptor(
            &sd,
            SECURITY_DESCRIPTOR_REVISION  // Required constant
            ) == FALSE)
        {
            //error;
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            return E_FAIL;
        }

        // Insert the DACL into the absolute SECURITY_DESCRIPTOR structure.
        if (SetSecurityDescriptorDacl(
            &sd,
            TRUE,
            pDacl,
            FALSE
            ) == FALSE)
        {
            //error;
            if(pUserSID)
            {
                FreeSid(pUserSID);
                pUserSID = NULL;
            }
            if(pEveryoneSid )
            {
                FreeSid(pEveryoneSid);
                pEveryoneSid = NULL;
            }
            if(pANONYMOUSSid)
            {
                FreeSid(pANONYMOUSSid);
                pANONYMOUSSid = NULL;
            }
            if(pDacl)
            {
                delete[] pDacl;
                pDacl=NULL;
            }
            return E_FAIL;
        }
/*
        if(pUserSID)
        {
            FreeSid(pUserSID);
            pUserSID = NULL;
        }
        if(pEveryoneSid )
        {
            FreeSid(pEveryoneSid);
            pEveryoneSid = NULL;
        }
        if(pANONYMOUSSid)
        {
            FreeSid(pANONYMOUSSid);
            pANONYMOUSSid = NULL;
        }
        if(pDacl)
        {
            delete[] pDacl;
            pDacl=NULL;
        }*/
 /*       return S_OK;
    }
    catch(...)
    {
        //error;
        if(pUserSID)
        {
            FreeSid(pUserSID);
            pUserSID = NULL;
        }
        if(pEveryoneSid )
        {
            FreeSid(pEveryoneSid);
            pEveryoneSid = NULL;
        }
        if(pANONYMOUSSid)
        {
            FreeSid(pANONYMOUSSid);
            pANONYMOUSSid = NULL;
        }
        if(pDacl)
        {
            delete[] pDacl;
            pDacl=NULL;
        }
        return E_FAIL;
    }
}
// yutianyi add end on 2010-09-15 for Change Record CFW005
// yutianyi add end on 2010-06-30 for Change Record CFW005&006
*/
// yangke delete end on 20101025 for directory structure change

// yutianyi add start on 2010-06-22 for Change Record CFW005
/**
* Send Synchronous message to check if special queue exist
* @param     hQueueHandle: the queue handle of specified queue.
* @param     bstrQName: the queue name of specified queue.
* @return    HRESULT: an error code if failed, S_OK if succeed.
* @since     1.00
*/
HRESULT InnerConnector::SendSyncMessToCheckQueue(
    const QUEUEHANDLE& hQueueHandle, const _bstr_t& bstrQName )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SendSyncMessToCheckQueue") );
    IMplusMessage *pMessageIn = MPlusMessageFactory::CreateMessage();
    if (NULL == pMessageIn)
    {
        // sunyongjie add start on 20101018 for tmsc review log
        ErrorDetail stErrorDetail;
        CString cTemp = _T("SendSyncMessToCheckQueue");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // sunyongjie add end on 20101018 for tmsc review log
        return E_FAIL;
    }

    if ( NULL == m_pMessageRet )
    {
        m_pMessageRet = MPlusMessageFactory::CreateMessage();
        if (NULL == m_pMessageRet)
        {
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendSyncMessToCheckQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            MPlusMessageFactory::DestroyMessage(pMessageIn);
            return E_FAIL;
        }
    }

    try
    {
        // check if send queue is exist?
        if ( NULL == hQueueHandle )
        {
            MPlusMessageFactory::DestroyMessage(pMessageIn);
            MPlusMessageFactory::DestroyMessage(m_pMessageRet);
            return E_FAIL;
        }

        pMessageIn->SetCommand( _bstr_t(static_cast<LPCWSTR>(
            MPLUSCFW_CHECK_QUEUE_MESSAGE )));
        pMessageIn->SetTimeOut( MPLUSCFW_CHECK_Q_TIMEOUT );
        // Validate message address
        pMessageIn->SetFromAddress( m_bstrRecvQ );
        pMessageIn->SetHostName( m_bstrMyHostName );
        pMessageIn->SetToAddress( bstrQName );

        m_bSendSyncMsg = true;
        ::ResetEvent( m_hSendSyncEvent );   

        // Set message priority
        pMessageIn->SetCallType( CFW_CALLTYPE_SYNC );

        DWORD dwTick = GetTickCount();
        WCHAR strTick[MPLUSCFW_WCHARARRAY_SIZE] = MPLUSCFW_EMPTY_STRING;

        // Prepare message property
        swprintf( strTick, _T( "%u" ), dwTick );
        pMessageIn->SetTimeStamp( _bstr_t( strTick ));

        // Set UID for message
        UINT64 unMsgUID = ::MPLUS::FW::COMM::GetMessageUID();
        pMessageIn->SetUID( unMsgUID );

        // Encode message
        _bstr_t bstrMsg = SerializeMsg( pMessageIn );

        // Bad message format
        if ( MPLUSCFW_EMPTYSTRING_LEN == bstrMsg.length())
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendSync");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)m_bstrRecvQ, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_BAD_MESG_FORMAT, 
                stErrorDetail );
            // yangke modified start on 2010-9-28 for code review log
            if(pMessageIn)
            {
                MPlusMessageFactory::DestroyMessage(pMessageIn);
            }
            // yangke  modified end on 2010-9-28 for code review log
            return ERROR_CFW_BAD_MESG_FORMAT;
        }
        int nPriorty = MPLUSCFW_PRIORITY_SYNC;

        if ( CFW_CALLTYPE_SYNC == pMessageIn->GetCallType())
        {
            m_uUidForSyncMessage =  pMessageIn->GetUID();
        }

        // yutianyi modify start on 2010-07-15 for Change Record CFW005
        /*HRESULT hr = SendMsg( hQueueHandle,
        FormatVersion( MPLUSCFW_COMM_VERSION ),
        bstrMsg, nPriorty, pMessageIn->GetTimeOut());*/
        //yangke 20100817 start
        _bstr_t bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
        if(MPLUSCFW_CONST_ZERO == m_bstrRecvQ.length()&& 
            pMessageIn->GetFromAddress().length() == MPLUSCFW_CONST_ZERO)
        {
            bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
        }
        else
        {
            bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            CString csFormatName = MPLUSCFW_EMPTY_STRING;
            if(pMessageIn->GetFromAddress().length() != MPLUSCFW_CONST_ZERO)
            {
                csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                    (LPTSTR)m_bstrMyHostName, (LPTSTR)pMessageIn->GetFromAddress());
            }
            else
            {
                csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                    (LPTSTR)m_bstrMyHostName, (LPTSTR)m_bstrRecvQ );
            }

            bstrFormatName = _bstr_t(static_cast<LPCWSTR>(csFormatName));
        }
        //yangke 20100817 end
        HRESULT hr = SendMsg( hQueueHandle,
            FormatVersion( MPLUSCFW_COMM_VERSION ),
            bstrMsg, nPriorty, pMessageIn->GetTimeOut(), bstrFormatName);
        // yangke modified start on 2010-9-28 for code review log
        if(pMessageIn)
        {
            MPlusMessageFactory::DestroyMessage(pMessageIn);
        }
        // yangke  modified end on 2010-9-28 for code review log
        // yutianyi modify end on 2010-07-15 for Change Record CFW005
        if ( FAILED( hr ))
        {
            m_uUidForSyncMessage = 0;
            return hr;
        }

        HANDLE hWaitHandle[WAITOBJECTCOUNT];
        hWaitHandle[FIRSTOBJECT] = NULL;
        hWaitHandle[SECONDOBJECT] = NULL;

        hWaitHandle[FIRSTOBJECT] = m_hSendSyncEvent;
        if ( NULL == hWaitHandle[FIRSTOBJECT] )
        {
            return ERROR_CFW_FAILED_RECV;
        }
        // for abort send sync
        hWaitHandle[SECONDOBJECT] = m_hSendSyncAbortEvent;           
        if ( NULL == hWaitHandle[SECONDOBJECT] )
        {            
            return ERROR_CFW_FAILED_RECV;
        }

        DWORD dResult = ::WaitForMultipleObjects( 
            WAITOBJECTCOUNT, hWaitHandle, FALSE, MPLUSCFW_CHECK_Q_TIMEOUT ); 

        if ( WAIT_OBJECT_0 == dResult )
        {
            return S_OK;
        }
        else if ( WAIT_OBJECT_0 +1 == dResult )
        {
            // Should notify other the call is aborted 
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendSyncMessToCheckQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return ERROR_CFW_USERABORT;
        }
        else if( WAIT_TIMEOUT == dResult)
        { 
            m_pMessageRet = NULL;
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendSyncMessToCheckQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_WAITTIMEOUT, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            hr = ERROR_CFW_WAITTIMEOUT;
            return hr;
        }
        else
        {
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SendSyncMessToCheckQueue");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return ERROR_CFW_FAILED_RECV;
        }
    }
    catch(...)
    {
        ErrorDetail stErrorDetail;
        CString cTemp = _T("SendSyncMessToCheckQueue");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMessageIn->GetToAddress(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMessageIn->GetFromAddress(), MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}

/**
* This method is used to send reply message.
* @param     pMsgIn: The input message
* @param     pMsgRet:The output message
* @return    HRESULT: The operation result.
* @since     1.00
*/
HRESULT InnerConnector::ReplyCheckMsg( const IMplusMessage* pMsgIn )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::ReplyCheckMsg") );
    if ( NULL == pMsgIn )
    {
        CFW_OUTPUT_ERROR( ERROR_CFW_INVALID_PARAMETERS );
        return ERROR_CFW_INVALID_PARAMETERS;
    }
    IMplusMessage *pMsgRet;
    pMsgRet = MPlusMessageFactory::CreateMessage();
    if ( NULL == pMsgRet )
    {
        return E_FAIL;
    }

    try
    {
        // The command can't be NULL.
        pMsgRet->SetCommand( _bstr_t( MPLUSCFW_CHECK_QUEUE_MESSAGE ));

        // Valid address and message have content
        // yutianyi modify start on 2010-07-23 for Change Record CFW003&004&005&006
        /*if (( pMsgIn->GetFromAddress().length() > MPLUSCFW_EMPTYSTRING_LEN ) &&
            ( pMsgIn->GetHostName().length() > MPLUSCFW_EMPTYSTRING_LEN ))*/
        if (( pMsgIn->GetFromAddress().length() > MPLUSCFW_EMPTYSTRING_LEN ) &&
            ( pMsgIn->GetSessionId().length() > MPLUSCFW_EMPTYSTRING_LEN ) &&
            ( pMsgIn->GetHostName().length() > MPLUSCFW_EMPTYSTRING_LEN ))
        // yutianyi modify end on 2010-07-23 for Change Record CFW003&004&005&006
        {
            // Fill the UID for the return message
            pMsgRet->SetReUID( pMsgIn->GetUID() );
            pMsgRet->SetUID( ::MPLUS::FW::COMM::GetMessageUID() );
            // Return message have the same call type with input message
            pMsgRet->SetCallType( pMsgIn->GetCallType() );
            pMsgRet->SetFromAddress( m_bstrRecvQ );
            if ( MPLUSCFW_EMPTYSTRING_LEN == pMsgRet->GetFromAddress().length())
            {
                pMsgRet->SetFromAddress( pMsgIn->GetToAddress() );
            }
            // yutianyi modify start on 2010-07-23 for Change Record CFW003&004&005&006
            //pMsgRet->SetToAddress( pMsgIn->GetFromAddress());
            CString csToAddress = MPLUSCFW_EMPTY_STRING;
            csToAddress.Format( _T("%s_%s"), (LPTSTR)pMsgIn->GetFromAddress(), 
                (LPTSTR)pMsgIn->GetSessionId());
            pMsgRet->SetToAddress( _bstr_t(csToAddress));
            // yutianyi modify end on 2010-07-23 for Change Record CFW003&004&005&006
            pMsgRet->SetHostName( m_bstrMyHostName );

            // Serialize the return message
            _bstr_t bstrMsgOut = InnerConnector::SerializeMsg( pMsgRet );
            // Bad message format
            if ( bstrMsgOut.length() == MPLUSCFW_EMPTYSTRING_LEN )
            {
                ErrorDetail stErrorDetail;
                TCHAR cTemp[MAX_LENGTH] = _T("SendReply");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgRet->GetSender(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMsgRet->GetFromAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMsgRet->GetToAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgRet->GetCommand(), MAX_LENGTH - InitOne );
                stErrorDetail.uUID = pMsgRet->GetUID();
                stErrorDetail.uReUID = pMsgRet->GetReUID();
                stErrorDetail.dTimeOut = pMsgRet->GetTimeOut();
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_BAD_MESG_FORMAT, 
                    stErrorDetail );
                // yangke modified start on 2010-9-28 for code review log
                if(pMsgRet)
                {
                    MPlusMessageFactory::DestroyMessage(pMsgRet);
                }
                // yangke  modified end on 2010-9-28 for code review log
                return ERROR_CFW_BAD_MESG_FORMAT;
            }

            // Set the priority for the message
            DWORD dwPriority = MPLUSCFW_PRIORITY_ASYNC;
            if ( pMsgIn->GetCallType() == CFW_CALLTYPE_SYNC )
            {
                dwPriority = MPLUSCFW_PRIORITY_SYNC;
            }

            // Send the return message
            // Open the queue first.
            QUEUEHANDLE hQueue = NULL;
            HRESULT hr = OpenQueue( pMsgRet->GetToAddress(), hQueue, 
                MQ_SEND_ACCESS, true, pMsgIn->GetHostName() );
            if ( S_OK != hr )
            {     
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SendReply");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgRet->GetSender(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMsgRet->GetFromAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMsgRet->GetToAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgRet->GetCommand(), MAX_LENGTH - InitOne );
                stErrorDetail.uUID = pMsgRet->GetUID();
                stErrorDetail.uReUID = pMsgRet->GetReUID();
                stErrorDetail.dTimeOut = pMsgRet->GetTimeOut();
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_OPEN, 
                    stErrorDetail );
                // yangke modified start on 2010-9-28 for code review log
                if(pMsgRet)
                {
                    MPlusMessageFactory::DestroyMessage(pMsgRet);
                }
                // yangke  modified end on 2010-9-28 for code review log
                return ERROR_CFW_FAILED_OPEN;
            } 
            // Send message.
            _bstr_t bstrLabel = FormatVersion( MPLUSCFW_COMM_VERSION );
            // yutianyi modify start on 2010-07-15 for Change Record CFW005
            /*hr = SendMsg( hQueue, bstrLabel, bstrMsgOut, 
            MPLUSCFW_PRIORITY_SYNC, INFINITE );*/
            _bstr_t bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            if(MPLUSCFW_CONST_ZERO == m_bstrRecvQ.length())
            {
                bstrFormatName = _bstr_t(MPLUSCFW_EMPTY_STRING);
            }
            else
            {
                CString csFormatName = MPLUSCFW_EMPTY_STRING;
                csFormatName.Format(MPLUSCFW_STRING_FORMATNAME_PREFIX, 
                    (LPTSTR)m_bstrMyHostName, (LPTSTR)m_bstrRecvQ );
                bstrFormatName = _bstr_t(static_cast<LPCWSTR>(csFormatName));
            }

            hr = SendMsg( hQueue, bstrLabel, bstrMsgOut, 
                MPLUSCFW_PRIORITY_SYNC, INFINITE, bstrFormatName );
            // yutianyi modify end on 2010-07-15 for Change Record CFW005

            // Close the queue.
            HRESULT hRes = CloseQueue( hQueue );
            if (FAILED(hRes))
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SendReply");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgRet->GetSender(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMsgRet->GetFromAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMsgRet->GetToAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgRet->GetCommand(), MAX_LENGTH - InitOne );
                stErrorDetail.uUID = pMsgRet->GetUID();
                stErrorDetail.uReUID = pMsgRet->GetReUID();
                stErrorDetail.dTimeOut = pMsgRet->GetTimeOut();
                CFW_OUTPUT_ERROR_DETAIL( hRes, 
                    stErrorDetail );
                // yangke modified start on 2010-9-28 for code review log
                if(pMsgRet)
                {
                    MPlusMessageFactory::DestroyMessage(pMsgRet);
                }
                // yangke  modified end on 2010-9-28 for code review log
            }
            if ( FAILED( hr ) )
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SendReply");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgRet->GetSender(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMsgRet->GetFromAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMsgRet->GetToAddress(), MAX_LENGTH - InitOne );
                CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgRet->GetCommand(), MAX_LENGTH - InitOne );
                stErrorDetail.uUID = pMsgRet->GetUID();
                stErrorDetail.uReUID = pMsgRet->GetReUID();
                stErrorDetail.dTimeOut = pMsgRet->GetTimeOut();
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_FAILED_SEND, 
                    stErrorDetail );
                if(pMsgRet)
                {
                    MPlusMessageFactory::DestroyMessage(pMsgRet);
                }
                return ERROR_CFW_FAILED_SEND;
            }
            if(pMsgRet)
            {
               // MPlusMessageFactory::DestroyMessage(pMsgRet);
            }
            return hr;
        }
        else
        {
            ErrorDetail stErrorDetail;
            TCHAR cTemp[MAX_LENGTH] = _T("SendReply");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgRet->GetSender(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMsgIn->GetToAddress(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMsgIn->GetFromAddress(), MAX_LENGTH - InitOne );
            CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgRet->GetCommand(), MAX_LENGTH - InitOne );
            stErrorDetail.uUID = pMsgRet->GetUID();
            stErrorDetail.uReUID = pMsgRet->GetReUID();
            stErrorDetail.dTimeOut = pMsgRet->GetTimeOut();
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_INVALID_ADDR, 
                stErrorDetail );
            if(pMsgRet)
            {
                MPlusMessageFactory::DestroyMessage(pMsgRet);
            }
            return ERROR_CFW_INVALID_ADDR;
        }
    }
    catch (...)
    {
        ErrorDetail stErrorDetail;
        TCHAR cTemp[MAX_LENGTH] = _T("SendReply");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderName, (LPCTSTR)pMsgRet->GetSender(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cSenderQName, (LPCTSTR)pMsgIn->GetToAddress(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cReceiverQName, (LPCTSTR)pMsgIn->GetFromAddress(), MAX_LENGTH - InitOne );
        CFW_COPY_STRING( stErrorDetail.cCommand, (LPCTSTR)pMsgRet->GetCommand(), MAX_LENGTH - InitOne );
        stErrorDetail.uUID = pMsgRet->GetUID();
        stErrorDetail.uReUID = pMsgRet->GetReUID();
        stErrorDetail.dTimeOut = pMsgRet->GetTimeOut();
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_EXCEPTION_UNKNOWN, 
            stErrorDetail );
        return ERROR_CFW_UNKNOWN_ERROR;
    }
}
// yutianyi add end on 2010-06-22 for Change Record CFW005

// yutianyi add start on 2010-09-15 for Change Record CFW005
/**
 * Query Session List
 * @param     arrSessionList: output session list
 * @return    int: number of sessions
 * @since     1.00
 */
// yangke modified start on 2010-9-28 for code review log
BOOL InnerConnector::QuerySessionList(int*& arrSessionList, int& nCount  )
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::QuerySessionList") );
    try
    {
        if (arrSessionList != NULL)
        {
            return FALSE;
        }
        nCount = -1;
        if ( NULL == m_pMessageRet )
        {
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("QuerySessionList");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return FALSE;
        }
        // session list information
        CString csParam = ( LPCTSTR )m_pMessageRet->GetParameter();

        CString* csSessionList = NULL; // decode session list
        BOOL bRet = SplitString(csParam,MPLUSCFW_BCMSG_SPLIT_CHARACTOR, nCount, csSessionList);
        if(bRet != TRUE)
        {
            if(csSessionList!=NULL)
            {
                delete[] csSessionList;
                csSessionList = NULL;
            }
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("QuerySessionList");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return FALSE;
        }
        arrSessionList = new int[nCount];
        if(arrSessionList==NULL)
        {
            if(csSessionList!=NULL)
            {
                delete[] csSessionList;
                csSessionList = NULL;
            }
            // sunyongjie add start on 20101018 for tmsc review log
            ErrorDetail stErrorDetail;
            CString cTemp = _T("QuerySessionList");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            // sunyongjie add end on 20101018 for tmsc review log
            return FALSE;
        }
        for (int i = 0; i < nCount; i++)
        {   // string to int 
            arrSessionList[i] = _wtoi(LPCTSTR(csSessionList[i]));
        }

        if(csSessionList!=NULL)
        {
            delete[] csSessionList;
            csSessionList = NULL;
        }
        return TRUE;
    }
    catch (...)
    {
        // sunyongjie add start on 20101018 for tmsc review log
        ErrorDetail stErrorDetail;
        CString cTemp = _T("QuerySessionList");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // sunyongjie add end on 20101018 for tmsc review log
        return FALSE;
    }
}
/**
 * SplitString
 * @param     CString: string to be split
 * @param     CString: string to be split by what
 * @param     CString*&: output session list string array
 * @return    BOOL: success or failure
 * @since     1.00
 */
BOOL InnerConnector::SplitString(CString str, CString split, int& iSubStrs, CString*& pOutArray)
{
    MPLUS_TRACE_FUNC_IN( _T("InnerConnector::SplitString") );
    int iPos = 0; 
    int iNums = 0; 
    CString strTemp = str;
    CString strRight;
    if(pOutArray != NULL)
    {
        // sunyongjie add start on 20101018 for tmsc review log
        ErrorDetail stErrorDetail;
        CString cTemp = _T("SplitString");
        CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
        CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
        // sunyongjie add end on 20101018 for tmsc review log
        return FALSE;
    }
    while (iPos != -1) // get amount of sessions
    {
        iPos = strTemp.Find(split);
        if (iPos == -1)
        {
            break;
        }
        strRight = strTemp.Mid(iPos + split.GetLength(), str.GetLength());
        strTemp = strRight;
        iNums++;
    }
    if (iNums == 0) 
    { // one session

        iSubStrs = 1; 
        // Modify778 begin for static code check
        //pOutArray = new CString[iSubStrs];
        //pOutArray[0] = str;
        try 
        {
            pOutArray = new CString[iSubStrs];
            if ( NULL == pOutArray )
            {
                ErrorDetail stErrorDetail;
                CString cTemp = _T("SplitString");
                CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
                CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
                return FALSE;
            }
            pOutArray[0] = str;
        }
        catch (...)
        {  
            return FALSE; 
        }
        return TRUE;
    }
    // amount of target host sessions
    iSubStrs = iNums+1; 

    //pOutArray = new CString[iSubStrs];
    try 
    {
        pOutArray = new CString[iSubStrs];
        if ( NULL == pOutArray )
        {
            ErrorDetail stErrorDetail;
            CString cTemp = _T("SplitString");
            CFW_COPY_STRING( stErrorDetail.cCondition, cTemp, MAX_LENGTH - InitOne );
            CFW_OUTPUT_ERROR_DETAIL( ERROR_CFW_UNKNOWN_ERROR, stErrorDetail );
            return FALSE;
        }
    }
    catch (...)
    {  
        return FALSE; 
    }
    // Modify778 end for static code check
    strTemp = str;
    CString strLeft;
    for (int i = 0; i < iNums; i++)
    {
        iPos = strTemp.Find(split);

        strLeft = strTemp.Left(iPos);

        strRight = strTemp.Mid(iPos + split.GetLength(), strTemp.GetLength());
        strTemp = strRight;
        pOutArray[i] = strLeft; // get session ID
    }
    pOutArray[iNums] = strTemp;
    return TRUE;
}
// yangke  modified end on 2010-9-28 for code review log
// yutianyi add end on 2010-09-15 for Change Record CFW005
        } // Namespace Comm
    } // Namespace FW
} // Namespace MPlus




